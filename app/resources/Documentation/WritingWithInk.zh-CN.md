# 使用墨水写作

## 关于本中文版与 Inky 中文化

本中文文档与 Inky 编辑器由社区进行了以下中文化工作，便于中文用户使用与学习 ink：

- **界面与文档**
  - 界面语言：在支持的系统/环境下可切换为简体中文（菜单、对话框等）。
- 工作语言：可通过 **帮助 → 工作语言 → 简体中文** 切换为中文界面与中文提示；同时会切换文档为中文版。

- **中文语法模式（视图 → 中文语法模式）**
  - 开启后可在 ink 脚本中使用中文关键字，与英文语法等价，可中英混写。例如：`节点` ↔ `===`，`跳转` ↔ `->`，`选项` ↔ `*`，`持久` ↔ `VAR`，`变量` ↔ `VAR`，`临时` ↔ `temp`，`列表` ↔ `LIST`，`常量` ↔ `CONST`，`包含` ↔ `INCLUDE`，`外部` ↔ `EXTERNAL`，`函数` ↔ `function` 等。
  - 编译前会做预处理，将中文关键字替换为 ink 语法，再交给 inklecate 编译。

- **错误信息与辅助**
  - 当界面语言为简体中文时，编译错误等信息会尽量翻译为中文提示。
  - 语法高亮支持上述中文关键字，与英文关键字一致高亮。
  - 新建主 ink 文件时的默认示例、以及部分代码片段，提供中文版本。

以上功能可在 **视图** 与 **帮助** 菜单中查看和切换；关闭“中文语法模式”后，仅使用标准英文 ink 语法。

---

<details>
  <summary>目录</summary>

  * [关于本中文版与 Inky 中文化](#关于本中文版与-inky-中文化)
  * [介绍](#介绍)
  * [第一部分：基础知识](#第一部分基础知识)
    * [1) 内容](#1-内容)
    * [2) 选择](#2-选择)
    * [3) 结](#3-结)
    * [4) 转向](#4-转向)
    * [5) 分支流程](#5-分支流程)
    * [6) 包含和缝合](#6-包含和缝合)
    * [7) 变化选择](#7-变化选择)
    * [8) 变量文本](#8-变量文本)
    * [9) 游戏查询和函数](#9-游戏查询和函数)
  * [第二部分：交织](#第二部分交织)
    * [1) 收集](#1-收集)
    * [2) 嵌套流程](#2-嵌套流程)
    * [3) 跟踪交织](#3-跟踪交织)
  * [第三部分：变量和逻辑](#第三部分变量和逻辑)
    * [1) 全局变量](#1-全局变量)
    * [2) 逻辑](#2-逻辑)
    * [3) 条件块 (if/else)](#3-条件块-ifelse)
    * [4) 临时变量](#4-临时变量)
    * [5) 函数](#5-函数)
    * [6) 常量](#6-常量)
    * [7) 高级：游戏端逻辑](#7-高级-游戏端逻辑)
   * [第四部分：高级流程控制](#第四部分-高级流程控制)
     * [1) 隧道](#1-隧道)
     * [2) 线程](#2-线程)
   * [第五部分：高级状态跟踪](#第五部分-高级状态跟踪)
     * [1) 基础列表](#1-基础列表)
	 * [2) 重用列表](#2-重用列表)
	 * [3) 列表值](#3-列表值)
	 * [4) 多值列表](#4-多值列表)
	 * [5) 高级列表操作](#5-高级列表操作)
	 * [6) 多列表列表](#6-多列表列表)
	 * [7) 长示例：犯罪现场](#7-长示例-犯罪现场)
	 * [8) 概要](#8-概要)
   * [第六部分：标识符中的国际字符支持](#第六部分-标识符中的国际字符支持)
</details>

## 介绍

**ink** 是一种脚本语言，围绕着用流来标记纯文本的理念构建，以便生成互动脚本。

在最基本的情况下，它可以用来写选择你自己的风格的故事，或是分支对话树。但它真正的强项在于编写有很多选项和流的再组合的对话。

**ink** 提供了几项功能，使非技术作家能够频繁分支，并以小和大方式呈现这些分支的后果，而不必麻烦。

脚本旨在保持清晰和逻辑有序，以便可以“目测”测试分支对话。流以声明性的方式描述，尽可能做到这一点。

它还考虑到重写的需求；因此，编辑一个流应该是快速的。

# 第一部分：基础知识

## 1) 内容

### 最简单的 Ink 脚本

最基本的 Ink 脚本就是一个 .ink 文件中的文本。

```
Hello, world!
```

运行时，这将输出内容，然后停止。

分开的行会产生新段落。脚本：

```
Hello, world!
Hello?
Hello, are you there?
```

产生的输出看起来是一样的。

### 注释

默认情况下，文件中的所有文本都会出现在输出内容中，除非特别标记。

最简单的标记是一种注释。**ink** 支持两种类型的注释。第一种是供阅读代码的人使用的，编译器会忽略：

	"What do you make of this?" she asked.

	// 一些无法打印的内容...

	"I couldn't possibly comment," I replied.

	/*
		... 或者是一个无限的文本块
	*/

另一种是用于提醒作者他们需要做什么，编译器在编译期间会打印出来：

	TODO: Write this section properly!

### 标签

游戏中的文本内容将在引擎运行时“原样”出现。然而，有时标记一行内容以附加信息，告诉游戏如何处理该内容是有用的。

**ink** 提供了一种简单的系统，可以用哈希标签为内容行添加标签。

    一行普通的游戏文本。# 将其标记为蓝色

这些标签不会出现在主要文本流中，但游戏可以读取并根据需要使用它们。更多信息请见 [运行你的 Ink](RunningYourInk.md#marking-up-your-ink-content-with-tags)。

## 2) 选择

通过文本选择向玩家提供输入。文本选择由 `*` 字符指示。

如果没有给出其他流程指令，一旦做出选择，该选择将流入下一行文本。

	Hello world!
	*	Hello back!
		Nice to hear from you!

这产生以下游戏：

	Hello world
	1: Hello back!

	> 1
	Hello back!
	Nice to hear from you.

默认情况下，选择的文本会在输出中再次出现。

### 抑制选择文本

一些游戏将选择的文本与其结果分开。在 **ink** 中，如果选择文本用方括号括起来，则该选择的文本不会打印到响应中。

	Hello world!
	*	[Hello back!]
		Nice to hear from you!

生成

	Hello world
	1: Hello back!

	> 1
	Nice to hear from you.

#### 高级：混合选择和输出文本

方括号实际上将选项内容分开。前面的内容在选择和输出中都被打印；内部的内容仅在选择中；而后面的内容仅在输出中。它们有效地提供了行结束的替代方式。

	Hello world!
	*	Hello [back!] right back to you!
		Nice to hear from you!

产生：

	Hello world
	1: Hello back!
	> 1
	Hello right back to you!
	Nice to hear from you.

这在编写对话选择时特别有用：

	"What's that?" my master asked.
	*	"I am somewhat tired[."]," I repeated.
		"Really," he responded. "How deleterious."

产生：

	"What's that?" my master asked.
	1. "I am somewhat tired."
	> 1
	"I am somewhat tired," I repeated.
	"Really," he responded. "How deleterious."

### 多项选择

为了使选择真正成为选择，我们需要提供替代选项。我们可以通过简单地列出它们来做到这一点：

	“那是什么？”我的主人问。
	*	“我有点累[。”]，我重复说。
		“真的吗，”他回答道。“多么有害。”
	*	“没什么，先生！”[] 我回答道。
		“很好，那就行。”
	*  “我说，这次旅程令人沮丧[。”]我想不再继续了。”
		“啊，”他回答，不是无情。“我看到你感到沮丧。明天，一切都会好转。”

这产生了以下游戏：

	“那是什么？”我的主人问。

	1: “我有点累。”
	2: “没什么，先生！”
	3: “我说，这次旅程令人沮丧。”

	> 3
	“我说，这次旅程令人沮丧，我想不再继续了。”
	“啊，”他回答，不是无情。“我看到你感到沮丧。明天，一切都会好转。”

上述语法足以写出一组选择。在一个真实的游戏中，我们希望根据玩家的选择将流程从一个点移动到另一个点。为此，我们需要引入更多的结构。

## 3) 绳结

### 内容片段称为节点

为了允许游戏分支，我们需要用名称标记内容的部分（就像老式游戏书中的“第18段”等一样）。

这些部分称为“节点”，它们是 ink 内容的基本结构单元。

### 编写一个结

结的开始由两个或更多的等号表示，如下所示。

	=== top_knot ===

（结尾的等号是可选的；并且名称需要是一个没有空格的单词。）

结的开始是一个标题，后面的内容将位于该结内。

	=== back_in_london ===

	我们在晚上9:45准确到达伦敦。

#### 高级：更复杂的“你好，世界”

当你启动一个 ink 文件时，结之外的内容将会自动运行。但结中的内容不会。因此，如果你开始使用结来保存你的内容，你需要告诉游戏该去哪里。我们用一个转移箭头 `->` 来实现这一点，详细内容将在下一节中讲解。

最简单的结脚本是：

	-> top_knot

	=== top_knot ===
	你好，世界！

然而，**ink** 不喜欢松散的结，并且在编译和/或运行时当它认为出现了这种情况时会产生警告。上面的脚本在编译时会产生如下警告：

	WARNING: Apparent loose end exists where the flow runs out. Do you need a '-> END' statement, choice or divert? on line 3 of tests/test.ink

运行时会产生以下错误：

	Runtime error in tests/test.ink line 3: ran out of content. Do you need a '-> DONE' or '-> END'?

以下代码可以无错误地播放和编译：

	=== top_knot ===
	你好，世界！
	-> END

`-> END` 是给作者和编译器的标记；它意味着“故事流程现在应该停止”。

## 4) 转向

### 结点转向结点

您可以通过 `->`，即“转向箭头”，讲述从一个结点转到另一个结点的故事。转向是立即发生的，无需用户输入。

	=== back_in_london ===

	我们准确在晚上9:45到达伦敦。
	-> hurry_home

	=== hurry_home ===
	我们尽快赶回萨维尔街。

#### 转向是不可见的

转向旨在无缝衔接，甚至可以在句中发生：

	=== hurry_home ===
	We hurried home to Savile Row -> as_fast_as_we_could

	=== as_fast_as_we_could ===
	as fast as we could.

产生的结果与上面的内容相同：

	We hurried home to Savile Row as fast as we could.

#### Glue

默认行为是在每个内容的新行之前插入换行符。然而在某些情况下，内容必须坚持不换行，它可以通过使用 `<>` 或 "胶水" 来实现这一点。

	=== hurry_home ===
	我们急着回家 <>
	-> to_savile_row

	=== to_savile_row ===
	到萨维尔街
	-> as_fast_as_we_could

	=== as_fast_as_we_could ===
	<> 尽可能快地。

也生成了：

	我们急着回家到萨维尔街尽可能快地。

你不能使用过多的胶水：多个胶水相邻没有额外的效果。（并且没有办法“取消”胶水；一旦一行是粘性的，它将保持粘性。）

## 5) 分支流程

### 基本分支

组合节点、选项和转移为我们提供了一个选择你自己的游戏的基本结构。

	=== paragraph_1 ===
	你站在Analand的墙边，手握剑。
	* [打开大门] -> paragraph_2
	* [砸开大门] -> paragraph_3
	* [转身回家] -> paragraph_4

	=== paragraph_2 ===
	你打开大门，走上小路。

	...

### 分支和合并

通过使用分流，编写者可以分支流程，并在不向玩家显示流程已经重新合并的情况下再次合并。

	=== back_in_london ===

	我们在晚上9点45分准时到达伦敦。

	*	“没有时间可浪费！”[] 我宣称。
		-> hurry_outside

	*	“先生，我们应该好好享受这一刻！”[] 我宣称。
		我的主人用力地打了我一巴掌，把我拖出了门。
		-> dragged_outside

	*	[我们匆匆回家] -> hurry_outside


	=== hurry_outside ===
	我们急匆匆回到萨维尔街 -> as_fast_as_we_could


	=== dragged_outside ===
	他坚持我们要急匆匆回到萨维尔街
	-> as_fast_as_we_could


	=== as_fast_as_we_could ===
	<> 尽可能快。

### 故事流程

节点和分支结合在一起，形成了游戏的基本故事流程。这个流程是“扁平”的——没有调用栈，且分支不会“返回”。

在大多数 ink 脚本中，故事流程从顶部开始，以一种意大利面般混乱的方式跳转，然后最终（希望如此）到达 `-> END`。

这种非常松散的结构意味着作者可以随心所欲地进行创作，分支和重新联合而不必担心自己在创造的结构。创建新分支或分支的过程中没有模板，也无需跟踪任何状态。

#### 高级：循环

您绝对可以使用转向（diverts）来创建循环内容，并且 **ink** 有几个功能可以利用这一点，包括让内容自我变化的方法，以及控制选项选择频率的方法。

有关更多信息，请参阅关于变化文本和 [条件选择](#conditional-choices) 的部分。

哦，以下是合法的，但并不是一个好主意：

	=== round ===
	and
	-> round

## 6) 包含和缝合

### 结可以细分

随着故事的延长，缺乏一些额外结构的情况下，故事会变得更难以组织。

结可以包含称为“缝合”的子部分。这些子部分使用单个等号标记。

	=== the_orient_express ===
	= in_first_class
		...
	= in_third_class
		...
	= in_the_guards_van
		...
	= missed_the_train
		...

例如，可以将一个结用于一个场景，而将缝合用于场景内的事件。

### 针脚有独特的名称

针脚可以通过其“地址”进行转向。

	*	[第三等级旅行]
		-> the_orient_express.in_third_class

	*	[在护卫车旅行]
		-> the_orient_express.in_the_guards_van

### 第一个针脚是默认的

转移到包含针脚的结点将转移到结中的第一个针脚。因此：

*	[头等舱旅行]  
	"头等舱，先生。还有哪里?"  
	-> the_orient_express  

与以下相同：

*	[头等舱旅行]  
	"头等舱，先生。还有哪里?"  
	-> the_orient_express.in_first_class  

(...除非我们改变结中针脚的顺序！)

你还可以在结的顶部包含任何内容，而不在任何针脚中。然而，你需要记得从中转移出去 - 引擎在处理完标题内容后*不会*自动进入第一个针脚。

=== the_orient_express ===

我们登上了火车，但去哪儿？  
*	[头等舱] -> in_first_class  
*	[二等舱] -> in_second_class  

= in_first_class  
	...  
= in_second_class  
	...  

### 本地转移

在一个结内部，您不需要使用全地址来进行缝合。

	-> the_orient_express

	=== the_orient_express ===
	= in_first_class
		我安顿好了我的主人。
		*	[移动到三等舱]
			-> in_third_class

	= in_third_class
		我自己进入了三等舱。

这意味着缝合和结不能共享名称，但多个结可以包含相同的缝合名称。（所以东方快车和蒙古号都可以有头等舱。）

如果使用了模糊的名称，编译器会给出警告。

### 脚本文件可以组合

您还可以通过使用包含语句将内容分割到多个文件中。

```
INCLUDE newspaper.ink
INCLUDE cities/vienna.ink
INCLUDE journeys/orient_express.ink
```

包含语句应始终放在文件的顶部，而不是放在结点内部。

没有关于结点必须在什么文件中才能被转移的规则。（换句话说，分离文件对游戏的命名空间没有影响）。

## 7) 不同的选择

### 选项只能使用一次

默认情况下，游戏中的每个选项只能选择一次。如果你的故事中没有循环，你将永远不会注意到这种行为。但如果你使用了循环，你会迅速注意到你的选项消失了...

	=== find_help ===

		You search desperately for a friendly face in the crowd.
		*	The woman in the hat[?] pushes you roughly aside. -> find_help
		*	The man with the briefcase[?] looks disgusted as you stumble past him. -> find_help

产生：

	你在茫茫人海中绝望地寻找一张友好的面孔。

	1: 帽子上的女人？
	2: 手拿公文包的男人？

	> 1
	帽子上的女人粗鲁地将你推开。
	你在茫茫人海中绝望地寻找一张友好的面孔。

	1: 手拿公文包的男人？

	>

... 在下一个循环中，你将没有可选项。

#### 备选选择

上面的示例停止在它的地方，因为下一个选择导致了“内容不足”的运行时错误。

	> 1
	拿着公文包的男人在你跌跌撞撞经过他时看起来很厌恶。
	你在拥挤的人群中拼命寻找一个友好的面孔。

运行时错误在 tests/test.ink 第 6 行：内容不足。你需要一个 '-> DONE' 或者 '-> END' 吗？

我们可以通过“备选选择”来解决这个问题。备选选择永远不会显示给玩家，但如果没有其他选项，它将被游戏“选择”。

备选选择只是一个“没有选择文本的选择”：

	*	-> out_of_options

而且，我们可以稍微滥用语法，使用“选择然后箭头”来制作一个带有内容的默认选择：

	* 	->
		穆尔德永远无法解释他是如何逃脱那个燃烧的货车的。 -> season_2

#### 备选选择示例

将其添加到之前的示例中，我们得到：

	=== find_help ===

		你在拥挤的人群中绝望地寻找一个友好的面孔。
		*	那个戴帽子的女人[?]粗鲁地把你推开。 -> find_help
		*	那个提公文包的男人[?]在你跌跌撞撞地经过他身边时露出了厌恶的神情。 -> find_help
		*	->
			但为时已晚：你倒在了站台上。这就是结局。
			-> END

并生成：

	你在拥挤的人群中绝望地寻找一个友好的面孔。

	1: 戴帽子的女人？
	2: 提公文包的男人？

	> 1
	那个戴帽子的女人粗鲁地把你推开。
	你在拥挤的人群中绝望地寻找一个友好的面孔。

	1: 提公文包的男人？

	> 1
	那个提公文包的男人在你跌跌撞撞地经过他身边时露出了厌恶的神情。
	你在拥挤的人群中绝望地寻找一个友好的面孔。
	但为时已晚：你倒在了站台上。这就是结局。

### 粘性选择

“只用一次”的行为当然并不是我们总想要的，因此我们有第二种选择：即“粘性”选择。粘性选择简单地就是说不会被耗尽，并用 `+` 项标记。

	=== homers_couch ===
		+	[再吃一个甜甜圈]
			你再吃一个甜甜圈。 -> homers_couch
		*	[下沙发]
			你奋力从沙发上站起来，去创作史诗般的诗歌。
			-> END

回退选择也可以是粘性的。

	=== conversation_loop
		*	[谈论天气] -> chat_weather
		*	[谈论孩子们] -> chat_children
		+	-> sit_in_silence_again

### 条件选择

您还可以手动开启和关闭选择。**ink** 提供了相当多的逻辑，但最简单的测试是“玩家是否见过某个特定内容”。

游戏中的每个结/缝都具有唯一的地址（以便可以转移到该位置），我们使用相同的地址来测试该内容是否已被见过。

	*	{ not visit_paris } 	[前往巴黎] -> visit_paris
	+ 	{ visit_paris 	 } 		[返回巴黎] -> visit_paris

	*	{ visit_paris.met_estelle } [ 拨打埃斯特尔女士电话 ] -> phone_estelle

请注意，测试 `knot_name` 成立的条件是*该结内的任何*缝都已被见过。

还要注意，条件不覆盖选项的单次行为，因此您仍然需要粘性选项来进行可重复的选择。

#### 高级：多个条件

您可以在一个选项上使用多个逻辑测试；如果这样做，*所有* 测试必须全部通过，选项才会出现。

	*	{ not visit_paris } 	[去巴黎] -> visit_paris
	+ 	{ visit_paris } { not bored_of_paris }
		[返回巴黎] -> visit_paris

#### 逻辑运算符：AND 和 OR

上述“多个条件”实际上只是带有常规编程 AND 运算符的条件。Ink 以常规方式支持 `and`（也写作 `&&`）和 `or`（也写作 `||`），以及括号。

	*	{ not (visit_paris or visit_rome) && (visit_london || visit_new_york) } [ 等待。去哪里？我很困惑。 ] -> visit_someplace

对于非程序员来说，`X and Y` 意味着 X 和 Y 都必须为真。`X or Y` 意味着任一或两者皆可。我们没有 `xor`。

您也可以使用标准的 `!` 作为 `not`，尽管有时这会让编译器困惑，认为 `{!text}` 是一次性的列表。我们建议使用 `not`，因为否定的布尔测试通常不会那么令人兴奋。

#### 高级：结/缝标签实际上是读取计数

测试：

	*	{seen_clue} [指控杰斐逊先生]

实际上是在测试一个*整数*而不是一个真/假标志。以这种方式使用的结或缝实际上是一个整数变量，包含玩家已看到该地址内容的次数。

如果它非零，在上述测试中将返回真，但您也可以更具体一些：

	* {seen_clue > 3} [直接逮捕杰斐逊先生]

#### 高级：更多逻辑

**ink** 支持比这里提到的更多逻辑和条件性 - 请参阅 [变量和逻辑](#part-3-variables-and-logic) 部分。

## 8) 可变文本

### 文本可以变化

到目前为止，我们看到的所有内容都是静态的、固定的文本。但内容也可以在打印时发生变化。

### 序列、循环和其他替代方案

文本的最简单变体是由替代方案提供的，这些替代方案根据某种规则进行选择。**ink** 支持几种类型。替代方案写在 `{`...`}` 花括号内，元素由 `|` 符号（垂直分隔线）分隔。

这些仅在某段内容被访问多次时才有用！

#### 替代选项类型

**序列**（默认）：

序列（或称为“停止块”）是一组替代选项，用于跟踪其出现的次数，每次出现时显示下一个元素。当没有新内容可显示时，它将继续显示最后一个元素。

    收音机嗡嗡响起。 {"三!"|"二!"|"一!"|爆炸的白噪音嘈杂声响起。|但这只是静电。}

    {我用我的五英镑钞票买了一杯咖啡.|我给我的朋友买了第二杯咖啡.|我没有足够的钱再买咖啡。}

**循环**（标记为 `&`）：

循环与序列类似，但它们对内容进行循环。

    今天是{&星期一|星期二|星期三|星期四|星期五|星期六|星期日}。

**仅一次**（标记为 `!`）：

仅一次替代选项与序列类似，但当没有新内容可以显示时，它们不显示任何内容。 （你可以将仅一次替代选项视为一个最后条目为空的序列。）

    他给我讲了一个笑话。 {!我礼貌地笑了。|我微笑了。|我面露难色。|我答应自己不再反应。}

**洗牌**（标记为 `~`）：

洗牌生成随机输出。

    我掷了硬币。 {~正面|反面}。

#### 替代方案的特性

替代方案可以包含空元素。

    I took a step forward. {!||||Then the lights went out. -> eek}

替代方案可以嵌套。

    The Ratbear {&{wastes no time and |}swipes|scratches} {&at you|into your {&leg|arm|cheek}}.

替代方案可以包含转移语句。

    I {waited.|waited some more.|snoozed.|woke up and waited more.|gave up and left. -> leave_post_office}

它们也可以在选择文本中使用：

    +  "Hello, {&Master|Monsieur Fogg|you|brown-eyes}!"[] I declared.

（...有一个注意事项；您不能用`{`开始选项的文本，因为它看起来像是一个条件。）

（...但这个注意事项有一个注意事项，如果在`{`之前转义一个空格`\ `，ink将把它识别为文本。）

    +\ {&They headed towards the Sandlands|They set off for the desert|The party followed the old road South}

#### 示例

替代选项可以在循环中使用，以创建智能、状态跟踪的游戏体验，而无需特别努力。

这是一个一结版本的打地鼠。请注意，我们使用了一次性选项和后备选项，以确保鼹鼠不会乱跑，游戏将始终结束。

	=== whack_a_mole ===
		{我举起锤子。|{~错过了！|没什么！|不好。它在哪？|啊哈！抓到它了！ -> END}}
		{&鼹鼠|{&坏的|该死的|丢脸的} {&生物|啮齿动物}} {在这里某个地方|藏在某个地方|仍然在游荡|在嘲笑我|仍然没有被打|注定要失败}。<>
		{!我会让它看看！|但这次它不会逃脱！}
		* 	[{&击打|砸|试试} 左上] 	-> whack_a_mole
		*  [{&重击|铲|击打} 右上] -> whack_a_mole
		*  [{&炸|锤} 中间] -> whack_a_mole
		*  [{&猛击|糟糕} 左下] 	-> whack_a_mole
		*  [{&钉|重击} 右下] 	-> whack_a_mole
		*   ->
        	    然后你因饥饿而倒下。鼹鼠击败了你！
	            -> END


产生以下“游戏”：

	我举起锤子。
	鼹鼠在这里某个地方。我会让它看看！

	1: 击打 左上
	2: 重击 右上
	3: 炸 中间
	4: 猛击 左下
	5: 钉 右下

	> 1
	错过了！
	那个可恶的生物在某个地方藏着。但这次它不会逃脱！

	1: 砸 右上
	2: 锤 中间
	3: 糟糕 左下
	4: 重击 右下

	> 4
	没什么！
	鼹鼠仍然在游荡。
	1: 击打 右上
	2: 炸 中间
	3: 猛击 左下

	> 2
	它在哪？
	那个该死的啮齿动物在嘲笑我。
	1: 重击 右上
	2: 糟糕 左下

	> 1
	啊哈！抓到它了！


下面是一些生活建议。注意这个粘人的选择——电视的诱惑永远不会消退：

	=== turn_on_television ===
	我打开了电视机 {第一次|第二次|又一次|再一次}，但 {没什么好看的，所以我又关掉了|仍然没有值得观看的节目|比以前更没东西吸引我的兴趣|只有垃圾|有个关于鲨鱼的节目，而我不喜欢鲨鱼|没什么}。
	+	[再试一次]	 		-> turn_on_television
	*	[改去外面走走]	-> go_outside_instead

    === go_outside_instead ===
    -> END

#### 预览：多行替代方案
**ink** 还有另一种格式，用于制作不同内容块的替代方案。有关详细信息，请参见 [多行块](#multiline-blocks) 部分。

### 条件文本

文本也可以根据逻辑测试的结果而变化，就像选项一样。

	{met_blofeld: "我见过他。只是片刻。" }

和

	"他的真名是 {met_blofeld.learned_his_name: 弗朗茨|一个秘密}."

这些可以作为单独的行出现，或在某个内容段落中出现。它们甚至可以嵌套，所以：

	{met_blofeld: "我见过他。只是片刻。他的真名是 {met_blofeld.learned_his_name: 弗朗茨|保留了秘密}." | "我错过了他。他特别邪恶吗？" }

可以生成以下内容之一：

	"我见过他。只是片刻。他的真名是 弗朗茨."

或者：

	"我见过他。只是片刻。他的真名是保留了秘密."

或者：

	"我错过了他。他特别邪恶吗？"

## 9) 游戏查询和函数

**ink** 提供了一些关于游戏状态的有用“游戏级”查询，用于条件逻辑。它们并不是语言的组成部分，但始终可用，并且不能被作者编辑。从某种意义上说，它们是语言的“标准库函数”。

约定是将这些命名为大写字母。

### CHOICE_COUNT()

`CHOICE_COUNT` 返回当前块中已创建的选项数量。例如：

	*	{false} 选项 A
	* 	{true} 选项 B
	*  {CHOICE_COUNT() == 1} 选项 C

生成两个选项，B 和 C。这对于控制玩家在轮次中获得多少选项非常有用。

### TURNS()

此函数返回自游戏开始以来的游戏回合数。

### TURNS_SINCE(-> knot)

`TURNS_SINCE` 返回自上次访问特定结点/缝合点以来的移动次数（正式来说，是玩家输入的次数）。

值为 0 表示“在当前片段中已被看到”。值为 -1 表示“从未被看到”。其他任何正值表示它在那么多回合前被看到过。

	*	{TURNS_SINCE(-> sleeping.intro) > 10} 你感到疲倦... -> sleeping
	* 	{TURNS_SINCE(-> laugh) == 0}  你试图停止笑。

请注意，传递给 `TURNS_SINCE` 的参数是一个“转移目标”，而不仅仅是结点地址本身（因为结点地址是一个数字 - 阅读计数 - 而不是故事中的位置...）

TODO: （要求在编译器中传递 `-c`）

#### 预览：在函数中使用 TURNS_SINCE

`TURNS_SINCE(->x) == 0` 测试非常有用，通常值得将其封装为一个 ink 函数。

	=== function came_from(-> x)
		~ return TURNS_SINCE(x) == 0

关于 [函数](#5-functions) 的部分稍微更清晰地概述了语法，但上述代码允许你这样表达：

	* {came_from(->  nice_welcome)} '我很高兴来到这里！'
	* {came_from(->  nasty_welcome)} '我们将保持简短。'

... 让游戏对玩家刚刚看到的内容做出反应。

### SEED_RANDOM()

出于测试目的，固定随机数生成器通常非常有用，这样在你每次玩的时候，墨水会产生相同的结果。你可以通过“给随机数系统设定种子”来做到这一点。

	~ SEED_RANDOM(235)

你传递给种子函数的数字是任意的，但提供不同的种子将导致不同的结果序列。

#### 高级：更多查询

您可以创建自己的外部函数，不过语法略有不同：请参见下面的[函数](#5-functions)部分。

# 第2部分：编织

到目前为止，我们已经以最简单的方式构建了分支故事，使用“选项”链接到“页面”。

但这要求我们为故事中的每个目的地命名，这可能会减慢写作速度，并抑制小分支的生成。

**ink** 提供了一种更强大的语法，旨在简化故事流程，适用于始终向前的方向（大多数故事都是如此，而大多数计算机程序则不是）。

这种格式被称为“编织”，它是基于基本的内容/选项语法构建的，增加了两个新特性：收集标记 `-`，和选项与收集的嵌套。

## 1) 收集器

### 聚集点将流程重新汇总

让我们回到本文档顶部的第一个多重选择示例。

	“那是什么？”我的主人问道。
		*	“我有点累[。”]，”我重复道。
			“真的吗，”他回应道。“多么有害。”
		*	“没什么，先生！”[]我答道。
		*  “我说过，这次旅程太糟糕了[。”]而且我不想再继续下去了。”
			“哦，”他回答道，语气不无善意。“我看到你感到沮丧。明天，事情会好起来的。”

在一个真实的游戏中，这三个选项可能会导致相同的结局——福克先生离开房间。我们可以通过聚集来做到这一点，而无需创建任何新的节点或添加任何分支。

	“那是什么？”我的主人问道。
		*	“我有点累[。”]，”我重复道。
			“真的吗，”他回应道。“多么有害。”
		*	“没什么，先生！”[]我答道。
			“很好，那么。”
		*  “我说过，这次旅程太糟糕了[。”]而且我不想再继续下去了。”
		“哦，”他回答道，语气不无善意。“我看到你感到沮丧。明天，事情会好起来的。”

	-	说完，福克先生离开了房间。

这产生了以下的游戏流程：

	“那是什么？”我的主人问道。

	1: “我有点累。”
	2: “没什么，先生！”
	3: “我说过，这次旅程太糟糕了。”

	> 1
	“我有点累，”我重复道。
	“真的吗，”他回应道。“多么有害。”
	说完，福克先生离开了房间。

### 选项与收集形成内容链

我们可以将这些收集和分支部分串联在一起，形成始终向前运行的分支序列。

	=== 逃避 ===
	我冲过丛林，狗在我的脚后面狂吠。

		* 	我检查了口袋里的珠宝[]，它们的触感让我更加轻快。 <>

		*  我没有停下来喘息[]，而是继续奔跑。 <>

		*	我欢呼着，心中充满喜悦。 <>

	- 	路应该不会太远！麦基会让引擎运转，然后我就安全了。

		*	我到达了道路，环顾四周[]. 你相信吗？
		* 	我得打断一下，麦基通常非常可靠[]. 他从来没有让我失望过。或者说，在那晚之前他从来没有失望过。

	-	道路是空的。麦基不见踪影。

这是最基本的一种编织方式。本节的其余部分详细介绍了允许编织嵌套、包含旁路和改道、自我偏移，以及最重要的，引用早期选择以影响后续选择的附加功能。

#### 编织哲学

编织不仅仅是分支流程的方便封装；它们还是创作更强大内容的一种方式。上面的 `escape` 示例已经有四条可能的路径，而一个更复杂的序列可能有更多的路径。使用普通的分流，需要通过从一个点追踪到另一个点来检查链接，这样容易导致错误的产生。

通过编织，流程保证从顶部开始并“下落”到底部。在基本的编织结构中，流程错误是不可能的，输出文本可以很容易地被浏览。这意味着无需实际测试游戏中的所有分支来确保它们按照预期工作。

编织还允许轻松重新草拟选择点；特别是，可以很容易地拆分一个句子并插入额外的选择，以增加多样性或节奏感，而无需重新设计任何流程。

## 2) 嵌套流程

上面展示的编织是相当简单的“平面”结构。无论玩家做什么，从上到下所用的回合数都是相同的。然而，有时某些选择需要更多的深度或复杂性。

为此，我们允许编织嵌套。

本节附带一个警告。嵌套编织非常强大且紧凑，但可能需要一些时间来适应！

### 选项可以嵌套

考虑以下场景：

	- 	“好吧，波洛？谋杀还是自杀？”
	*	“谋杀！”
	* 	“自杀！”
	- 克里斯蒂女士稍微低下了她的手稿。其他写作小组成员目瞪口呆地坐着。

第一个提出的选择是“谋杀！”或“自杀！”。如果波洛宣称是自杀，那就没有更多内容可讨论，但如果是谋杀，就需要一个后续问题——他怀疑谁？

我们可以通过一组嵌套的子选项来添加新选项。我们告诉剧本这些新选项是“部分属于”另一个选择，使用两个星号，而不是一个。

	- 	“好吧，波洛？谋杀还是自杀？”
		*	“谋杀！”
		 	“那是谁干的？”
			* * 	“侦探警长贾普！”
			* * 	“海斯廷斯船长！”
			* * 	“我自己！”
		* 	“自杀！”
		- 克里斯蒂女士稍微低下了她的手稿。其他写作小组成员目瞪口呆地坐着。

（请注意，缩进用于显示嵌套是良好的风格，但编译器不介意。）

如果我们想向另一条路线添加新的子选项，我们可以以类似的方式进行。

	- 	“好吧，波洛？谋杀还是自杀？”
		*	“谋杀！”
		 	“那是谁干的？”
			* * 	“侦探警长贾普！”
			* * 	“海斯廷斯船长！”
			* * 	“我自己！”
		* 	“自杀！”
			“真的，波洛？你确定吗？”
			* * 	“很确定。”
			* *		“这显而易见。”
		- 克里斯蒂女士稍微低下了她的手稿。其他写作小组成员目瞪口呆地坐着。

现在，最初的指控选择将引导到特定的后续问题——无论如何，流程将在克里斯蒂女士的客串出现时汇聚在一起。

但是，如果我们想要一个更扩展的子场景呢？

### 收集要点也可以嵌套

有时候，这不是扩大选择数量的问题，而是有超过一个额外情节的需求。我们可以通过将收集要点嵌套在选项中来实现这一点。

- 	“Well, Poirot? Murder or suicide?”
		*	“Murder!”
			“And who did it?”
			* * 	“Detective-Inspector Japp!”
			* * 	“Captain Hastings!”
			* * 	“Myself!”
			- - 	“You must be joking!”
			* * 	“Mon ami, I am deadly serious.”
			* *		“If only...”
		* 	“Suicide!”
			“Really, Poirot? Are you quite sure?”
			* * 	“Quite sure.”
			* *		“It is perfectly obvious.”
		-	Mrs. Christie lowered her manuscript a moment. The rest of the writing group sat, open-mouthed.

如果玩家选择“谋杀”选项，他们将在其子分支上有两个连续的选择——仅为他们提供的一个完整的扁平结构。

#### 高级：Gathers 的作用

Gathers 的功能应该直观，但它们的行为有点难以用语言表达：一般来说，在选择了一个选项后，故事会找到下一个不在更低层级的 gather，并转向它。

基本思想是这样的：选项将故事的路径分开，而 gathers 将它们重新汇聚在一起。（因此，称为“编织”！）

### 你可以嵌套任意多的层级

在上面，我们使用了两个层级的嵌套；主流和子流。但没有限制你可以深入多少层级。

	-	“讲个故事吧，船长！”
		*	“很好，你们这些海狗。这里有一个故事...”
			* * 	“那是一个阴暗而暴风雨的夜晚...”
					* * * 	“...船员们都很烦躁...”
							* * * *  “...他们对船长说道...”
									* * * * *		“...讲个故事吧，船长！”
		*	“不，可以，你们已经到了睡觉时间。”
 	-	全体船员开始打哈欠。

过一段时间，这种子嵌套会变得难以阅读和操作，因此如果旁支选择变得笨重，最好是转向新的结构。

但至少在理论上，你可以将整个故事写成一个单一的编织。

### 示例：带有嵌套节点的对话

这是一个更长的例子：

	- 我看着福格先生
	*	... 我再也控制不住自己了。
		'我们的旅程目的是什么，先生？'
		'打赌，' 他回答。
		* * 	'打赌！'[] 我回答道。
				他点了点头。
				* * * 	'但这显然是愚蠢的！'
				* * *  '那么这是个非常严肃的问题！'
				- - - 	他又点了点头。
				* * *	'但我们能赢吗？'
						'这就是我们将要努力弄清楚的，' 他回答。
				* * *	'我希望是个小打赌？'
						'两万英镑，' 他平静地回答。
				* * * 	我就没有再问他其他问题[.]，在最后一次礼貌地咳嗽后，他没有再对我说什么。<>
		* * 	'啊[.],' 我回答，不确定我在想什么。
		- - 	之后，<>
	*	... 但我什么也没说[] 并且<>
	- 我们在沉默中度过了这一天。
	- -> 结束

有几种可能的游戏玩法。一个简短的：

	我看着福格先生

	1: ... 我再也控制不住自己了。
	2: ... 但我什么也没说

	> 2
	... 但我什么也没说，我们在沉默中度过了这一天。

和一个更长的：

	我看着福格先生

	1: ... 我再也控制不住自己了。
	2: ... 但我什么也没说

	> 1
	... 我再也控制不住自己了。
	'我们的旅程目的是什么，先生？'
	'打赌，' 他回答。

	1: '打赌！'
	2: '啊。'

	> 1
	'打赌！' 我回答。
	他点了点头。

	1: '但这显然是愚蠢的！'
	2: '那么这是个非常严肃的问题！'

	> 2
	'那么这是个非常严肃的问题！'
	他又点了点头。

	1: '但我们能赢吗？'
	2: '我希望是个小打赌？'
	3: 我就没有再问他其他问题。

	> 2
	'我希望是个小打赌？'
	'两万英镑，' 他平静地回答。
	之后，我们在沉默中度过了这一天。

希望这证明了上述的哲学：编织提供了一种紧凑的方式来提供大量的分支和选择，但保证能够从开始到结束！

## 3) 跟踪编织

有时，编织结构是足够的。但当它不足时，我们需要更多的控制。

### Weaves 是 largely unaddressed

默认情况下，weave 中的内容行没有地址或标签，这意味着它们无法被分流，也无法被测试。在最基本的 weave 结构中，选择会改变玩家在 weave 中的路径和所见内容，但一旦 weave 完成，这些选择和路径就会被遗忘。

但如果我们想要记住玩家所见的内容，我们可以 - 在需要的地方添加标签，使用 `(label_name)` 语法。

### 收集与选项可以被标记

在任何嵌套层级，收集点可以使用括号进行标记。

	-  (top)

一旦被标记，收集点可以像节点和缝合一样被转移或在条件中进行测试。这意味着你可以使用之前的决策来改变编织内部后续的结果，同时仍然保留清晰、可靠的前向流动的所有优势。

选项也可以被标记，就像收集点一样，使用括号。标签括号出现在行中的条件之前。

这些地址可以在条件测试中使用，这对于创建由其他选项解锁的选项是非常有用的。

	=== meet_guard ===
	守卫皱着眉头看着你。

	* 	(greet) [问候他]
		'你好。'
	*	(get_out) '滚开[。]，'你对守卫说。

	- 	'嗯，'守卫回答。

	*	{greet} 	'今天过得不错吗？' // 仅当你向他问候时

	* 	'嗯？'[]你回答。

	*	{get_out} [推他到一边] 	 // 仅当你威胁过他时
		你猛地推了他一把。他愣住了，拔出剑来！
		-> fight_guard 			// 该路线脱离了编织

	-	'呜呜，'守卫回应，然后递给你一个纸袋。'太妃糖？'

### 范围

在同一个编织块内，您可以简单地使用标签名称；在块外，您需要一个路径，要么指向同一节点内的另一个针脚：

	=== knot ===
	= stitch_one
		- (gatherpoint) 一些内容。
	= stitch_two
		*	{stitch_one.gatherpoint} 选项

或者指向另一个节点：

	=== knot_one ===
	-	(gather_one)
		* {knot_two.stitch_two.gather_two} 选项

	=== knot_two ===
	= stitch_two
		- (gather_two)
			*	{knot_one.gather_one} 选项

#### 高级：所有选项都可以被标记

实际上，墨水中的所有内容都是一种编织，即使没有可见的褶皱。这意味着你可以使用括号标签为游戏中的 *任何* 选项标记，然后使用寻址语法进行引用。特别地，这意味着你可以测试玩家选择了 *哪个* 选项以达到特定的结果。

	=== fight_guard ===
	...
	= throw_something
	*	(rock) [向警卫扔石头] -> throw
	* 	(sand) [向警卫扔沙子] -> throw

	= throw
	你向警卫投掷了 {throw_something.rock:一块石头|一把沙子}。

#### 高级：织物中的循环

标记允许我们在织物中创建循环。以下是询问NPC的标准模式。

	- (opts)
		*	'我能从哪里得到制服？'[] 你问快乐的守卫。
			'当然。在储物柜里。' 他咧嘴一笑。'不过，我可不认为它会适合你。'
		*	'告诉我关于安全系统的事。'
			'这是古老的，'守卫向你保证。'和煤一样古老。'
		*	'有狗吗？'
			'有成百上千只，'守卫带着灿烂的笑容回答。'而且它们很饿。'
		// 我们要求玩家至少问一个问题
		*	{loop} [够多了，别再说了]
			-> done
	- (loop)
		// 在守卫感到无聊之前循环几次
		{ -> opts | -> opts | }
		他挠了挠头。
		'嗯，不能整天站在这里闲聊，'他宣称。
	- (done)
		你感谢守卫，然后离开。

#### 高级：转向选项

选项也可以转向：但转向的结果是选择该选项的输出，*就好像该选项已经被选择一样*。因此，打印的内容将忽略方括号中的文本，如果选项是一次性使用的，它将被标记为已用完。

	- (opts)
	*	[做鬼脸]
		你做了个鬼脸，士兵向你冲来！ -> 推开

	*	(推开) [把守卫推到一边] 你把守卫推到一边，但他又挥拳过来了。

	*	{推开} [抓住并战斗] -> fight_the_guard

	- 	-> opts

生成：

	1: 做鬼脸
	2: 把守卫推到一边

	> 1
	你做了个鬼脸，士兵向你冲来！你把守卫推到一边，但他又挥拳过来了。

	1: 抓住并战斗

	>

#### 高级：选项后直接收集

以下是有效且经常有用的示例。

	*	"您很好吗，先生？"[] 我问。
		- - (quitewell) "很好，" 他回答。
	*	"您在填字游戏中表现如何，先生？"[] 我问。
		-> quitewell
	*	我什么也没说[] 我的老师也没有说。
	-	我们再次沉浸在友好的沉默中。

注意第一个选项下方的二级收集点：在这里实际上没有什么可以收集的，但它为我们提供了一个方便的地方来转移第二个选项。

# 第三部分：变量与逻辑

到目前为止，我们已经使用基于玩家已经看到的内容的测试创建了条件文本和条件选择。

**ink** 还支持变量，包括临时变量和全局变量，存储数值和内容数据，或者甚至是故事流程命令。它在逻辑方面功能全面，并包含一些额外的结构，以帮助更好地组织分支故事中常常复杂的逻辑。

## 1) 全局变量

最强大的变量类型，并且可以说是故事中最有用的，是存储游戏状态某些独特属性的变量——从主角口袋里的钱数，到代表主角心理状态的值。

这种变量被称为“全局”变量，因为它可以从故事的任何地方访问——既可以设置，也可以读取。（传统编程试图避免这种情况，因为它允许程序的一个部分干扰另一个不相关的部分。但故事就是故事，而故事全关乎结果：在拉斯维加斯发生的事情很少会留在那里。）

### 定义全局变量

全局变量可以在任何地方定义，使用 `VAR` 语句。它们应被赋予初始值，这定义了它们的变量类型——整数、浮点数（小数）、内容或故事地址。

	VAR knowledge_of_the_cure = false
	VAR players_name = "Emilia"
	VAR number_of_infected_people = 521
	VAR current_epilogue = -> they_all_die_of_the_plague


### 使用全局变量

我们可以测试全局变量来控制选项，并提供条件文本，这与我们之前看到的方式类似。

	=== the_train ===
		火车颠簸而响亮。我感到还算不错，不过，也不在意偶尔的颠簸。{ mood > 0:我感到足够积极，然而，并不介意偶尔的颠簸|这超出了我能承受的范围}。
		*	{ not knows_about_wager } '但是，先生，我们为什么要旅行呢？'[] 我问道。
		* 	{ knows_about_wager} 我沉思着我们的奇怪冒险[]. 这可能吗？

#### 高级：将推导存储为变量

“推导”语句实际上是一种值，可以被存储、修改并进行推导。

	VAR 	current_epilogue = -> everybody_dies

	=== continue_or_quit ===
	现在放弃，还是继续尝试拯救你的王国？
	*  [继续尝试！] 	-> more_hopeless_introspection
	*  [放弃] 		-> current_epilogue

#### 高级：全局变量在外部可见

全局变量可以从运行时和故事中访问和修改，因此提供了一种良好的方式来在更广泛的游戏和故事之间进行通信。

**ink** 层通常是存储游戏变量的好地方；不用考虑保存/加载问题，并且故事本身可以对当前值做出反应。

### 打印变量

变量的值可以使用类似于序列和条件文本的内联语法作为内容打印：

	VAR friendly_name_of_player = "Jackie"
	VAR age = 23

	我叫让·帕斯帕图，但我朋友称呼我为 {friendly_name_of_player}。我 {age} 岁。

这在调试时非常有用。有关基于逻辑和变量的更复杂打印，请参见函数部分。

### 评估字符串

可能会注意到，上面我们提到变量能够包含“内容”，而不是“字符串”。这是故意的，因为在 ink 中定义的字符串可以包含墨水——尽管它总是会评估为字符串。（哎呀！）

	VAR a_colour = ""

	~ a_colour = "{~red|blue|green|yellow}"

	{a_colour}

... 产生红色、蓝色、绿色或黄色中的一种。

请注意，一旦像这样的内容被评估，其值是“粘性的”。（量子态崩溃。）所以以下内容：

	那个流氓打了你，火花在你眼前飞溅，{a_colour} 和 {a_colour}。

... 不会产生非常有趣的效果。（如果你真的想让它生效，请使用文本函数来打印颜色！）

这也是为什么

	VAR a_colour = "{~red|blue|green|yellow}"

是明确禁止的；它将在故事构建时被评估，这可能不是你想要的效果。

## 2) 逻辑

显然，我们的全局变量并不是常量，因此我们需要一种语法来更改它们。

由于默认情况下，任何文本在 **ink** 脚本中都会直接打印到屏幕上，我们使用标记符号来表明某一行内容是打算进行某些数值运算的，我们使用 `~` 标记。

以下语句都将值赋给变量：


	=== set_some_variables ===
		~ knows_about_wager = true
		~ x = (x * x) - (y * y) + c
		~ y = 2 * x * y

以下语句将测试条件：

	{ x == 1.2 }
	{ x / 2 > 4 }
	{ y - 1 <= x * x }

### 数学

**ink** 支持四个基本的数学运算（`+`，`-`，`*` 和 `/`），以及 `%`（或 `mod`），它返回整数除法后的余数。此外，还有 POW 用于幂计算：

	{POW(3, 2)} 为 9。
	{POW(16, 0.5)} 为 4。

如果需要更复杂的运算，可以编写函数（如有必要使用递归），或调用外部的游戏代码函数（用于任何更高级的操作）。

#### RANDOM(min, max)

Ink 可以通过 RANDOM 函数生成随机整数。RANDOM 被设计得像骰子（是的，饰物，我们说的是 *一个骰子*），因此最小值和最大值都是包含在内的。

	~ temp dice_roll = RANDOM(1, 6)

	~ temp lazy_grading_for_test_paper = RANDOM(30, 75)

	~ temp number_of_heads_the_serpent_has = RANDOM(3, 8)

随机数生成器可以为测试目的设置种子，详情请参见上方的游戏查询和函数部分。

#### 高级: 数值类型是隐式的

操作的结果 - 特别是对于除法 - 是根据输入的类型来确定的。因此，整数除法返回整数，而浮点除法返回浮点结果。

``` 
~ x = 2 / 3 
~ y = 7 / 3 
~ z = 1.2 / 0.5 
```

将 `x` 赋值为 0，`y` 赋值为 2，`z` 赋值为 2.4。

#### 高级：INT()、FLOOR() 和 FLOAT()

在您不想要隐式类型的情况下，或者您想要对变量进行舍入时，可以直接进行类型转换。

	{INT(3.2)} 是 3。
	{FLOOR(4.8)} 是 4。
	{INT(-4.8)} 是 -4。
	{FLOOR(-4.8)} 是 -5。

	{FLOAT(4)} 是，嗯，仍然是 4。

### 字符串查询

出乎意料的是，对于一个文本引擎，**ink** 在字符串处理方面的功能并不多：假设你需要的任何字符串转换都将由游戏代码来处理（可能还有外部函数）。但我们支持三种基本查询 - 相等、不相等和子串（我们称之为 ?，原因将在后面的章节中变得清晰）。

以下所有表达式均返回 true：

``` 
{ "Yes, please." == "Yes, please." }
{ "No, thank you." != "Yes, please." }
{ "Yes, please" ? "ease" }
```

## 3) 条件块 (if/else)

我们已经看到条件用于控制选项和故事内容；**ink** 还提供了常规 if/else-if/else 结构的等价方法。

### 一个简单的 'if'

if 语法从迄今为止使用的其他条件语句中获得灵感，`{`...`}` 语法表示正在测试某些内容。

	{ x > 0:
		~ y = x - 1
	}

可以提供 else 条件：

	{ x > 0:
		~ y = x - 1
	- else:
		~ y = x + 1
	}

### 扩展的 if/else if/else 块

上述语法实际上是更一般结构的一个特定情况，类似于另一种语言中的 "switch" 语句：

	{
		- x > 0:
			~ y = x - 1
		- else:
			~ y = x + 1
	}

通过使用这种形式，我们可以包含 'else-if' 条件：

	{
		- x == 0:
			~ y = 0
		- x > 0:
			~ y = x - 1
		- else:
			~ y = x + 1
	}

（请注意，和其他所有内容一样，空格仅仅是为了可读性，且没有语法意义。）

### Switch 块

还有一个实际的 switch 语句：

	{ x:
	- 0: 	零
	- 1: 	一
	- 2: 	二
	- else: 很多
	}

#### 示例：上下文相关内容

请注意，这些测试不必基于变量，也可以使用访问计数，正如其他条件语句一样，并且以下结构相当常见，作为表达“做一些与当前游戏状态相关的内容”的一种方式：

	=== dream ===
		{
			- visited_snakes && not dream_about_snakes:
				~ fear++
				-> dream_about_snakes

			- visited_poland && not dream_about_polish_beer:
				~ fear--
				-> dream_about_polish_beer

			- else:
				// 基于早餐的梦没有影响
				-> dream_about_marmalade
		}

该语法的优点是易于扩展和优先分配。

### 条件块不仅限于逻辑

条件块可以用来控制故事内容以及逻辑：

    我盯着福克先生。
    { know_about_wager:
        <> "但你肯定不是认真的吧？" 我问道。
    - else:
        <> "但这次旅行一定有原因，" 我观察到。
    }
    他没有回答，只是像昆虫学家仔细研究自己最新固定的标本一样，专心看着他的报纸。

你甚至可以在条件块中放置选项：

    { door_open:
        *   我走出了隔间[]，我觉得我听到我的主人轻声自言自语。
                -> go_outside
    - else:
        *   我请求离开[]，福克先生看起来很惊讶。  -> open_door
        *   我站起身去打开门[]。福克先生似乎并没有因为这个小叛逆而感到不安。 -> open_door
    }

...但是请注意，上述示例中缺少 weave 语法和嵌套并不是偶然的：为了避免混淆各种嵌套工作，条件块中不允许包含聚集点。

### 多行块

还有另一类多行块，它扩展了上述替代方案系统。以下都是有效的，并且执行您可能期望的操作：

 	// 顺序：逐个遍历替代方案，最后停留在最后一个
	{ stopping:
		- 我进入了赌场。
		- 我再次进入了赌场。
		- 我又一次走了进去。
	}

	// 随机：随机显示一个
	在桌子上，我抽到了一张牌。 <>
	{ shuffle:
		- 红心王牌。
		- 黑桃国王。
		- 方块2。
			“这次你输啦！”庄家得意洋洋地说道。
	}

	// 循环：依次显示每一个，然后循环
	{ cycle:
		- 我屏住了呼吸。
		- 我焦急地等待。
		- 我暂停了一下。
	}

	// 一次：依次显示每一个，直到所有都展示完
	{ once:
		- 我的运气会持续吗？
		- 我能赢得这一局吗？
	}

#### 高级：修改后的洗牌

上面的洗牌块实际上是一个“洗牌循环”；它会洗牌内容，播放它，然后重新洗牌并再次开始。

还有两个其他版本的洗牌：

`shuffle once` 将洗牌内容，播放它，然后什么也不做。

	{ shuffle once:
	-	太阳很热。
	- 	这是一个炎热的日子。
	}

`shuffle stopping` 将洗牌所有内容（除了最后一个条目），并在播放完后停留在最后一个条目上。

	{ shuffle stopping:
	- 	一辆银色的宝马轰鸣而过。
	-	一辆明亮的黄色跑车转弯。
	- 	这里有很多车。
	}

## 4) 临时变量

### 临时变量用于临时计算

有时，全局变量使用起来不太方便。**ink** 提供了临时变量以便快速计算事物。

	=== near_north_pole ===
		~ temp number_of_warm_things = 0
		{ blanket:
			~ number_of_warm_things++
		}
		{ ear_muffs:
			~ number_of_warm_things++
		}
		{ gloves:
			~ number_of_warm_things++
		}
		{ number_of_warm_things > 2:
			尽管下着雪，我仍感到无比温暖。
		- else:
			那天晚上我比以往任何时候都要冷。
		}

临时变量中的值在故事离开定义它的拼接之后会被丢弃。

### 节点和缝合可以接受参数

一种特别有用的临时变量形式是参数。任何节点或缝合都可以被赋予一个值作为参数。

	*	[指控哈斯廷斯]
			-> accuse("Hastings")
	*	[指控布莱克夫人]
			-> accuse("Claudia")
	*	[指控自己]
			-> accuse("myself")

	=== accuse(who) ===
		"我指控 {who}!" 波洛宣称。
		"真的?" 贾普回答道。"{who == "myself":你做的?|{who}?}"
		"那为什么不呢?" 波洛回击道。

... 而且如果你想将一个临时值从一个缝合传递到另一个，你将需要使用参数！

#### 示例：递归结点定义

临时变量在递归中是安全的（与全局变量不同），因此下面的代码将有效。

	-> add_one_to_one_hundred(0, 1)

	=== add_one_to_one_hundred(total, x) ===
		~ total = total + x
		{ x == 100:
			-> finished(total)
		- else:
			-> add_one_to_one_hundred(total, x + 1)
		}

	=== finished(total) ===
		"结果是 {total}!" 你宣布。
		高斯惊恐地盯着你。
		-> END


（实际上，这种定义足够有用，以至于 **ink** 提供了一种特殊的结点，称之为 `function`，它有某些限制并且可以返回一个值。请参阅下面的部分。）

#### 进阶：作为参数发送转移目标

Knot/stitch 地址是一种值，由 `->` 字符表示，可以被存储和传递。因此，以下是合法的，并且通常是有用的：

	=== sleeping_in_hut ===
		你躺下，闭上了眼睛。
		-> generic_sleep (-> waking_in_the_hut)

	===	 generic_sleep (-> waking)
		你睡着了，或许梦见什么等等等。
		-> waking

	=== waking_in_the_hut
		你重新站起身，准备继续你的旅程。

...但是请注意 `generic_sleep` 定义中的 `->`：这是 **ink** 中参数需要被类型化的唯一情况：因为否则很容易意外地做以下操作：

	=== sleeping_in_hut ===
		你躺下，闭上了眼睛。
		-> generic_sleep (waking_in_the_hut)

... 这会将 `waking_in_the_hut` 的读取计数发送到 sleeping knot 中，然后尝试转移到它。

## 5) 函数

在节点上使用参数意味着它们在常规意义上几乎是函数，但它们缺少一个关键概念 - 调用栈和返回值的使用。

**ink** 包含函数：它们是节点，具有以下限制和特性：

一个函数：
- 不能包含缝合
- 不能使用转移或提供选择
- 可以调用其他函数
- 可以包含打印内容
- 可以返回任何类型的值
- 可以安全地递归

（其中一些可能看起来相当限制，但对于更面向故事的调用栈样式特性，请参阅关于 [隧道](#1-tunnels) 的部分。）

返回值通过 `~ return` 语句提供。

### 定义和调用函数

要定义一个函数，只需声明一个节点为：

	=== function say_yes_to_everything ===
		~ return true

	=== function lerp(a, b, k) ===
		~ return ((b - a) * k) + a

函数通过名称和括号调用，即使它们没有参数：

	~ x = lerp(2, 8, 0.3)

	*	{say_yes_to_everything()} '是的。'

与其他语言一样，一个函数完成后，会将流程返回到它被调用的地方 - 尽管不允许偏离流程，函数仍然可以调用其他函数。

	=== function say_no_to_nothing ===
		~ return say_yes_to_everything()

### 函数不必返回任何值

一个函数不需要有返回值，可以简单地完成一些值得打包的事情：

	=== function harm(x) ===
		{ stamina < x:
			~ stamina = 0
		- else:
			~ stamina = stamina - x
		}

...不过请记住，函数不能中断，因此虽然上述代码防止了负 Stamina 值，但它不会杀死一个 Stamina 值为零的玩家。

### 函数可以被内联调用

函数可以在 `~` 内容行上被调用，也可以在内容的某一部分被调用。在这个上下文中，如果有返回值，则返回值会被打印（以及函数想打印的任何其他内容）。如果没有返回值，则不会打印任何内容。

内容默认是“粘合在一起”的，因此以下内容：

    Monsieur Fogg was looking {describe_health(health)}.

    === function describe_health(x) ===
    {
    - x == 100:
        ~ return "spritely"
    - x > 75:
        ~ return "chipper"
    - x > 45:
        ~ return "somewhat flagging"
    - else:
        ~ return "despondent"
    }

会产生：

    Monsieur Fogg was looking despondent.

#### 示例

例如，您可能会包括：

	=== function max(a,b) ===
		{ a < b:
			~ return b
		- else:
			~ return a
		}

	=== function exp(x, e) ===
		// 返回 x 的 e 次方，其中 e 是一个整数
		{ e <= 0:
			~ return 1
		- else:
			~ return x * exp(x, e - 1)
		}

然后：

	2^5 和 3^3 的最大值是 {max(exp(2,5), exp(3,3))}。

产生：

	2^5 和 3^3 的最大值是 32。

#### 示例：将数字转化为文字

以下示例虽然较长，但在目前为止的每个 inkle 游戏中几乎都有出现。（请记住，注意符号在多行大括号内的连接线表示“要测试的条件”或者，如果大括号以变量开头，则表示“要比较的值”。）

    === function print_num(x) ===
    {
        - x >= 1000:
            {print_num(x / 1000)} 千 { x mod 1000 > 0:{print_num(x mod 1000)}}
        - x >= 100:
            {print_num(x / 100)} 百 { x mod 100 > 0:and {print_num(x mod 100)}}
        - x == 0:
            零
        - else:
            { x >= 20:
                { x / 10:
                    - 2: 二十
                    - 3: 三十
                    - 4: 四十
                    - 5: 五十
                    - 6: 六十
                    - 7: 七十
                    - 8: 八十
                    - 9: 九十
                }
                { x mod 10 > 0:<>-<>}
            }
            { x < 10 || x > 20:
                { x mod 10:
                    - 1: 一
                    - 2: 二
                    - 3: 三
                    - 4: 四
                    - 5: 五
                    - 6: 六
                    - 7: 七
                    - 8: 八
                    - 9: 九
                }
            - else:
                { x:
                    - 10: 十
                    - 11: 十一
                    - 12: 十二
                    - 13: 十三
                    - 14: 十四
                    - 15: 十五
                    - 16: 十六
                    - 17: 十七
                    - 18: 十八
                    - 19: 十九
                }
            }
    }

这使我们可以写出类似这样的语句：

	~ price = 15

	我从口袋里拿出 {print_num(price)} 个硬币，慢慢地数了起来。
	“哦，没关系，”商人回答说。“我就要一半。”然后她拿走了 {print_num(price / 2)}，把其余的推回给我。

### 参数可以通过引用传递

函数参数也可以通过“引用”传递，这意味着函数实际上可以修改传入的变量，而不是创建一个具有该值的临时变量。

例如，大多数 **inkle** 故事包括以下内容：

```
=== function alter(ref x, k) ===
    ~ x = x + k
```

类似如下的语句：

```
~ gold = gold + 7
~ health = health - 4
```

现在可以变成：

```
~ alter(gold, 7)
~ alter(health, -4)
```

这样稍微更容易阅读，并且（更有用的是）可以在线内执行，以达到最大紧凑性。

* 我吃了一块饼干[]，感觉焕然一新。{alter(health, 2)}
* 我把一块饼干给了蒙席·福格[]，他狼吞虎咽地吃掉了它。{alter(foggs_health, 1)}
- <> 然后我们继续前行。

将简单操作封装在函数中，还可以在需要时提供一个放置调试信息的简单位置。

##  6) 常量

### 全局常量

交互式故事通常依赖于状态机，跟踪某个更高层次过程已达到的阶段。实现这一点的方法有很多，但最方便的是使用常量。

有时，定义常量为字符串是方便的，这样可以在游戏玩法或调试时将它们打印出来。

```plaintext
CONST HASTINGS = "Hastings"
CONST POIROT = "Poirot"
CONST JAPP = "Japp"

VAR current_chief_suspect = HASTINGS

=== review_evidence ===
    { found_japps_bloodied_glove:
        ~ current_chief_suspect = POIROT
    }
    当前嫌疑人: {current_chief_suspect}
```

有时给它们赋值是有用的：

```plaintext
CONST PI = 3.14
CONST VALUE_OF_TEN_POUND_NOTE = 10
```

有时数字在其他方面也很有用：

```plaintext
CONST LOBBY = 1
CONST STAIRCASE = 2
CONST HALLWAY = 3

CONST HELD_BY_AGENT = -1

VAR secret_agent_location = LOBBY
VAR suitcase_location = HALLWAY

=== report_progress ===
{  secret_agent_location == suitcase_location:
    秘密特工抓住了行李箱！
    ~ suitcase_location = HELD_BY_AGENT

-  secret_agent_location < suitcase_location:
    秘密特工向前移动。
    ~ secret_agent_location++
}
```

常量只是一种让你为故事状态赋予易于理解名称的方法。

## 7) 高级：游戏侧逻辑

在 **ink** 引擎中，有两种核心方式来提供游戏钩子。ink 中的外部函数声明允许您直接调用游戏中的 C# 函数，而变量观察者是在 ink 变量被修改时在游戏中触发的回调。这两者都在 [Running your ink](RunningYourInk.md) 中进行了描述。

# 第4部分：高级流程控制

## 1) 隧道

**ink** 故事的默认结构是一个“扁平”的选择树，分支并重新汇聚，可能形成循环，但故事始终处于“某个地方”。

但这种扁平结构使某些事情变得困难：例如，想象一个游戏，其中可以发生以下交互：

	=== crossing_the_date_line ===
	*	“先生！”[] 我突然惊恐地宣布。“我刚刚意识到。我们已经跨越国际日期变更线了！”
	- 先生·福克几乎没有抬起眉毛。“我已对此进行了调整。”
	* 我擦了擦额头上的汗水[]。真是松了一口气！
	* 我点了点头，心如止水[]. 当然他已经调整过了！
	* 我在心里咒骂[]. 我又一次被轻视了！

...但这可以在故事的多个不同地方发生。我们不想为每个不同的地方写内容的副本，但当内容完成时，需要知道要返回哪里。我们可以使用参数来做到这一点：

	=== crossing_the_date_line(-> return_to) ===
	...
	-	-> return_to

	...

	=== outside_honolulu ===
	我们到达了大岛檀香山。
	- (附言)
		-> crossing_the_date_line(-> done)
	- (完成)
		-> END

	...

	=== outside_pitcairn_island ===
	小船沿着水面驶向小岛。
	- (附言)
		-> crossing_the_date_line(-> done)
	- (完成)
		-> END

这两个地点现在都调用并执行相同的故事流程，但结束后它们会返回到下一个需要去的地方。

但如果被调用的故事部分更复杂——如果它跨越多个节点呢？使用上述方法，我们必须不断从一个节点传递“返回到”的参数，以确保我们始终知道要返回哪儿。

因此，**ink** 将此集成到语言中，提供了一种新类型的转移，起作用的方式类似于子程序，称为“隧道”。

### 隧道运行子故事

隧道语法看起来像是一个分支，末尾还有另一个分支：

	-> crossing_the_date_line ->

这意味着“执行 crossing_the_date_line 故事，然后从这里继续”。

在隧道内部，语法简化为参数化示例：我们所做的只是使用 `->->` 语句结束隧道，这实质上意味着“继续”。

	=== crossing_the_date_line ===
	// 这是一个隧道！
	...
	- 	->->

请注意，隧道节点并不被声明为这样，因此编译器不会检查隧道是否真的以 `->->` 语句结束，只有在运行时会进行检查。因此，您需要仔细编写以确保所有流入隧道的部分都真的能再出来。

隧道也可以串联在一起，或以常规分支结束：

	...
	// 这会运行隧道，然后分支到 'done'
	-> crossing_the_date_line -> done
	...

	...
	// 这会运行一个隧道，然后另一个，然后分支到 'done'
	-> crossing_the_date_line -> check_foggs_health -> done
	...

隧道可以嵌套，因此以下内容是有效的：

	=== plains ===
	= night_time
		黑暗的草在你脚下是柔软的。
		+	[睡觉]
			-> sleep_here -> wake_here -> day_time
	= day_time
		是时候继续前进了。

	=== wake_here ===
		你在太阳升起时醒来。
		+	[吃点东西]
			-> eat_something ->
		+	[采取行动]
		-	->->

	=== sleep_here ===
		你躺下并试着闭上眼睛。
		-> monster_attacks -> 
		然后是睡觉的时间。
		-> dream -> 
		->->

… 以及其他内容。

#### 高级: 隧道可以返回其他地方

有时，在故事中，会发生一些事情。因此，有时隧道无法保证它总是想返回它来的地方。**ink** 提供了一种语法来允许你“从隧道返回，但实际上去别的地方”，但应该谨慎使用，因为感到非常困惑的可能性确实很高。

尽管如此，仍然有些情况下这是不可或缺的：

	=== fall_down_cliff 
	-> hurt(5) -> 
	你还活着！你爬起来继续走。

	=== hurt(x)
		~ stamina -= x 
		{ stamina <= 0:
			->-> youre_dead
		}
	
	=== youre_dead
	突然，你周围充满了白光。手指从你的额头上拿起一个目镜。‘你输了，伙计。离开椅子。’

即使在不那么极端的情况下，我们可能仍然想打断结构：

	-> talk_to_jim ->

	 === talk_to_jim
	 - (opts) 	
		*	[ 询问关于波动拉塞尔 ] 
			-> warp_lacells ->
		*	[ 询问关于护盾发生器 ] 
			-> shield_generators ->	
		* 	[ 停止交谈 ]
			->->
	 - -> opts 

	 = warp_lacells
		{ shield_generators : ->-> argue }
		"别担心波动拉塞尔。它们很好。"
		->->

	 = shield_generators
		{ warp_lacells : ->-> argue }
		"别担心护盾发生器。它们很好。"
		->->

	 = argue 
	 	"这些问题怎么回事？" 吉姆突然问道。 
	 	...
	 	->->

#### 高级：隧道使用调用栈

隧道位于调用栈上，因此可以安全地递归。

## 2) 线程

到目前为止，虽然有很多分支和转折，ink中的一切都是完全线性的。但实际上，作家可以将故事“分叉”为不同的子部分，以覆盖更多可能的玩家行为。

我们称之为“线程”，虽然这并不是真正意义上计算机科学家所说的线程：更像是从不同地方缝合新的内容。

请注意，这绝对是一个高级特性：一旦涉及线程，工程故事会变得稍微复杂一些！

### 线程将多个部分组合在一起

线程允许您一次性从多个来源组合内容部分。例如：

    == thread_example ==
    我头疼；线程的概念很难理解。
    <- conversation
    <- walking

    == conversation ==
    这对Monty和我来说是一个紧张的时刻。
     * "你今天午餐吃了什么？"[] 我问。
        "午餐肉和鸡蛋，" 他回答。
     * "今天天气不错，"[] 我说。
        "我见过更好的，" 他回答。
     - -> house

    == walking ==
    我们继续沿着尘土飞扬的路走。
     * [继续走]
        -> house

    == house ==
    不久，我们就到了他的家。
    -> END

它允许多个故事部分组合成一个单独的部分：

    我头疼；线程的概念很难理解。
    这对Monty和我来说是一个紧张的时刻。
    我们继续沿着尘土飞扬的路走。
    1: "你今天午餐吃了什么？"
    2: "今天天气不错，"
    3: 继续走

当遇到像`<- conversation`这样的线程语句时，编译器将分叉故事流程。第一个考虑的分叉将运行`conversation`中的内容，收集它找到的任何选项。一旦在此处耗尽了流程，它将运行其他分叉。

所有内容都被收集并展示给玩家。但是，当做出选择时，引擎将转向故事的那个分叉，并折叠并丢弃其他的。

请注意，全局变量*不会*被分叉，包括节点和缝合的阅读计数。

### 线程的用途

在一个普通的故事中，线程可能永远不需要。

但是对于具有许多独立运动部分的游戏而言，线程很快就变得至关重要。想象一下一个角色在地图上独立移动的游戏：一个房间的主要故事中心可能看起来像下面这样：

	CONST HALLWAY = 1
	CONST OFFICE = 2

	VAR player_location = HALLWAY
	VAR generals_location = HALLWAY
	VAR doctors_location = OFFICE

	== run_player_location
		{
			- player_location == HALLWAY: -> hallway
		}

	== hallway ==
		<- characters_present(HALLWAY)
		*	[抽屉]	-> examine_drawers
		* 	[衣橱] -> examine_wardrobe
		*  [去办公室] 	-> go_office
		-	-> run_player_location
	= examine_drawers
		// 等等...

	// 这是线程，它会在此时与您共享房间的角色中混合对话。

	== characters_present(room)
		{ generals_location == room:
			<- general_conversation
		}
		{ doctors_location == room:
			<- doctor_conversation
		}
		-> DONE

	== general_conversation
		*	[问将军关于沾血的刀]
			"我可以告诉你，这是一桩糟糕的事情。"
		-	-> run_player_location

	== doctor_conversation
		*	[问医生关于沾血的刀]
			"血没有什么奇怪的，对吧？"
		-	-> run_player_location



特别需要注意的是，我们需要一种明确的方式让走上侧线程的玩家返回到主流程。在大多数情况下，线程要么需要一个参数告诉它们返回到哪里，要么需要结束当前的故事部分。

### 侧线程何时结束？

侧线程在没有流程可处理时结束：请注意，它们会收集选项以便稍后显示（与隧道不同，隧道会收集选项、显示它们并跟随直到遇到显式返回，可能是在几步之后）。

有时线程没有内容可提供——也许与某个角色根本没有对话，或者我们只是还没有写出来。在这种情况下，我们必须明确标记线程的结束。

如果不这样做，内容的结束可能会导致故事漏洞或悬而未决的故事线程，我们希望编译器能告诉我们这些问题。

### 使用 `-> DONE`

在我们想要标记线程结束的情况下，我们使用 `-> DONE`：这意味着“流程在这里故意结束”。如果不这样做，我们可能会收到警告信息 - 我们仍然可以进行游戏，但这提醒我们还有未完成的任务。

本节开始的例子会生成一个警告；可以通过以下方式修复：

    == thread_example ==
    我头疼；线程很难理解。
    <- conversation
    <- walking
    -> DONE

额外的 DONE 告诉 ink 这里的流程已经结束，它应该依赖于线程来继续故事的下一部分。

请注意，如果流程以失败条件的选项结束，我们不需要 `-> DONE`。引擎将其视为有效的、故意的流程结束状态。

**选择选项后不需要 `-> DONE`**。一旦选择了选项，线程就不再是线程 - 它再次简单地是正常的故事流程。

在这种情况下使用 `-> END` 会结束整个故事流程，而不是线程。（这就是为什么有两种不同的方式来结束流程的真正原因。）

#### 示例：将相同的选择添加到多个地方

线程可以用来将相同的选择添加到许多不同的地方。当以这种方式使用它们时，通常会将一个分发作为参数传递，以告诉故事在选择完成后该去哪里。

	=== outside_the_house
	前台阶。房子散发着味道。谋杀的味道，以及薰衣草的香味。
	- (top)
		<- review_case_notes(-> top)
		*	[走过前门]
			我走进了房子。
			-> the_hallway
		* 	[闻闻空气]
			我讨厌薰衣草。这让我想起肥皂，肥皂让我想起我的婚姻。
			-> top

	=== the_hallway
	走廊。前门开向街道。一张小写字台。
	- (top)
		<- review_case_notes(-> top)
		*	[走过前门]
			我走到凉爽的阳光下。
			-> outside_the_house
		* 	[打开写字台]
			钥匙。更多的钥匙。甚至更多的钥匙。这些人需要多少把锁？
			-> top

	=== review_case_notes(-> go_back_to)
	+	{not done || TURNS_SINCE(-> done) > 10}
		[查看我的案件笔记]
		// 条件确保你无法重复检查选项
	 	{我|再次，我} 翻阅了到目前为止记下的笔记。仍然没有明显的嫌疑人。
	- 	(done) -> go_back_to

请注意，这与隧道不同，隧道运行相同的内容块，但不让玩家选择。因此，像这样的布局：

	<- childhood_memories(-> next)
	*	[看向窗外]
	 	我在我们驶过时白日做梦...
	 - (next) 然后哨音响起...

可能做的事情与：

	*	[回忆我的童年]
		-> think_back ->
	*	[看向窗外]
		我在我们驶过时白日做梦...
	- 	(next) 然后哨音响起...

实际做的事情完全相同，但只要被串联的选项包含多个选择，或者对选择的条件逻辑（或任何文本内容，当然！），线程版本就变得更加实用。

#### 示例：广泛选择点的组织

一个使用 ink 作为脚本而非字面输出的游戏，可能会生成非常大量的并行选择，旨在通过玩家的其他游戏内交互（例如在环境中走动）进行筛选。在这些情况下，线程可以用来划分选择。

```
=== the_kitchen
- (top)
	<- drawers(-> top)
	<- cupboards(-> top)
	<- room_exits
= drawers (-> goback)
	// 关于抽屉的选择...
	...
= cupboards(-> goback)
	// 关于橱柜的选择
	...
= room_exits
	// 出口；不需要“返回点”，因为如果你离开，就会去其他地方
	...
```

# 第五部分：高级状态跟踪

交互性强的游戏很快就会变得非常复杂，编剧的工作往往不仅仅是内容的创作，还包括保持连续性。

如果游戏文本旨在建模任何事物，这一点尤其重要——无论是纸牌游戏，玩家对游戏世界的了解，还是房屋中各种灯开关的状态。

**ink** 不提供经典解析器 IF 编程语言那样的完整世界建模系统——没有“对象”，没有“包含”或“开启”或“锁定”的概念。但它提供了一种简单而强大的系统，以非常灵活的方式跟踪状态变化，使编剧能够在必要时近似世界模型。

#### 注意：新功能警报！

这个功能对于该语言来说非常新。这意味着我们尚未开始探讨它可能被使用的所有方式——但我们相当确定它会很有用！所以如果您想到了一些聪明的用法，我们很想知道！

## 1) 基本列表

状态跟踪的基本单元是一个使用 `LIST` 关键字定义的状态列表。请注意，列表实际上与C#列表（数组）非常不同。

例如，我们可以有：

	LIST kettleState = cold, boiling, recently_boiled

这行代码定义了两件事：首先是三个新值 - `cold`、`boiling` 和 `recently_boiled` - 其次是一个变量，称为 `kettleState`，用于保存这些状态。

我们可以告诉列表取什么值：

	~ kettleState = cold

我们可以改变这个值：

	*	[打开水壶]
		水壶开始冒泡和沸腾。
		~ kettleState = boiling

我们可以查询这个值：

	*	[触摸水壶]
		{ kettleState == cold:
			水壶触感凉爽。
		- else:
			水壶的外部非常温暖！
		}

为了方便，我们可以在定义列表时使用括号给它一个值：

	LIST kettleState = cold, (boiling), recently_boiled
	// 在游戏开始时，这个水壶是开启的。太刺激了，对吧？

...如果这种表示法看起来有些冗余，接下来的几节将会有原因解释。

## 2) 重用列表

上述例子适用于水壶，但如果我们在炉子上也有一个锅呢？我们可以定义一个状态列表，但将它们放入变量中——可以使用任意多个变量。

```
LIST daysOfTheWeek = Monday, Tuesday, Wednesday, Thursday, Friday
VAR today = Monday
VAR tomorrow = Tuesday
```

### 状态可以重复使用

这允许我们在多个地方使用相同的状态机。

```
LIST heatedWaterStates = cold, boiling, recently_boiled
VAR kettleState = cold
VAR potState = cold

*	{kettleState == cold} [打开水壶]
	水壶开始沸腾和冒泡。
	~ kettleState = boiling
*	{potState == cold} [点燃炉灶]
	锅中的水开始沸腾和冒泡。
	~ potState = boiling
```

但如果我们也添加一个微波炉呢？我们可能想要开始泛化我们的功能：

```
LIST heatedWaterStates = cold, boiling, recently_boiled
VAR kettleState = cold
VAR potState = cold
VAR microwaveState = cold

=== function boilSomething(ref thingToBoil, nameOfThing)
	{nameOfThing} 开始加热。
	~ thingToBoil = boiling

=== do_cooking
*	{kettleState == cold} [打开水壶]
	{boilSomething(kettleState, "kettle")}
*	{potState == cold} [点燃炉灶]
	{boilSomething(potState, "pot")}
*	{microwaveState == cold} [打开微波炉]
	{boilSomething(microwaveState, "microwave")}
```

或者甚至…

```
LIST heatedWaterStates = cold, boiling, recently_boiled
VAR kettleState = cold
VAR potState = cold
VAR microwaveState = cold

=== cook_with(nameOfThing, ref thingToBoil)
+ 	{thingToBoil == cold} [打开 {nameOfThing}]
	{nameOfThing} 开始加热。
	~ thingToBoil = boiling
	-> do_cooking.done

=== do_cooking
<- cook_with("kettle", kettleState)
<- cook_with("pot", potState)
<- cook_with("microwave", microwaveState)
- (done)
```

请注意，“heatedWaterStates” 列表仍然可用，并且仍然可以进行测试并取一个值。

#### 列表值可以共享名称

重用列表会带来模糊性。如果我们有：

```
LIST colours = red, green, blue, purple
LIST moods = mad, happy, blue

VAR status = blue
```

... 编译器怎么知道你想要哪个蓝色呢？

我们使用类似于结和缝合所用的 `.` 语法来解决这些问题。

```
VAR status = colours.blue
```

... 编译器将会在你指定之前发出错误。

请注意，“状态的姓”与包含状态的变量是完全独立的。因此

```
{ statesOfGrace == statesOfGrace.fallen:
	// 当前状态是“fallen”
}
```

... 是正确的。

#### 高级：LIST 实际上是一个变量

一个令人惊讶的特性是语句

``` 
LIST statesOfGrace = ambiguous, saintly, fallen 
```

实际上同时执行了两个操作：它创建了三个值，`ambiguous`、`saintly` 和 `fallen`，并根据需要将它们命名为父项 `statesOfGrace`；同时创建了一个名为 `statesOfGrace` 的变量。

这个变量可以像普通变量一样使用。因此，以下内容是有效的，尽管令人困惑且是个坏主意：

```
LIST statesOfGrace = ambiguous, saintly, fallen

~ statesOfGrace = 3.1415 // 将变量设置为一个不是列表值的数字
```

……而且这并不会妨碍以下内容正常使用：

```
~ temp anotherStateOfGrace = statesOfGrace.saintly 
```

## 3) 列出值

当定义一个列表时，值是按顺序列出的，并且这个顺序被视为重要。实际上，我们可以把这些值当作数字来处理。（也就是说，它们是枚举。）

	LIST volumeLevel = off, quiet, medium, loud, deafening
	VAR lecturersVolume = quiet
	VAR murmurersVolume = quiet

	{ lecturersVolume < deafening:
		~ lecturersVolume++

		{ lecturersVolume > murmurersVolume:
			~ murmurersVolume++
			低声议论越来越大声。
		}
	}

值本身可以使用通常的 `{...}` 语法进行打印，但这将打印它们的名称。

	讲师的声音变成了 {lecturersVolume}。

### 将值转换为数字

如果需要，可以使用 LIST_VALUE 函数显式获取数值。请注意，列表中的第一个值为 1，而不是 0。

	讲师还有 {LIST_VALUE(deafening) - LIST_VALUE(lecturersVolume)} 个音量级可用。

### 将数字转换为值

您可以通过将列表的名称用作函数来反向操作：

    LIST Numbers = one, two, three
    VAR score = one
    ~ score = Numbers(2) // score 将是 "two"

### 高级：定义您自己的数值

默认情况下，列表中的值从1开始，每次增加1，但如果需要，您可以指定自己的值。

    LIST primeNumbers = two = 2, three = 3, five = 5

如果您指定了一个值，但没有指定下一个值，ink将假定增量为1。因此，以下是相同的：

    LIST primeNumbers = two = 2, three, five = 5

## 4) 多值列表

以下示例都包含一个故意的不实信息，我们现在将其去除。列表 - 以及包含列表值的变量 - 不必只包含一个值。

### 列表是布尔集合

列表变量不是包含数字的变量。相反，列表就像住宿楼的进出名称板。它包含一个名称列表，每个名称都有一个关联的房间号，并且有一个滑块表示“在”或“出”。

也许没有人进来：

	LIST DoctorsInSurgery = Adams, Bernard, Cartwright, Denver, Eamonn

也许每个人都在：

	LIST DoctorsInSurgery = (Adams), (Bernard), (Cartwright), (Denver), (Eamonn)

或者有些人在，有些人不在：

	LIST DoctorsInSurgery = (Adams), Bernard, (Cartwright), Denver, Eamonn

括号中的名称包含在列表的初始状态中。

请注意，如果您正在定义自己的值，可以将括号放在整个术语周围或仅放在名称周围：

	LIST primeNumbers = (two = 2), (three) = 3, (five = 5)

#### 同时赋予多个值

我们可以一次性赋予列表的所有值，如下所示：

```
~ DoctorsInSurgery = (Adams, Bernard)
~ DoctorsInSurgery = (Adams, Bernard, Eamonn)
```

我们可以将空列表赋值以清空列表：

```
~ DoctorsInSurgery = ()
```

#### 添加和移除条目

列表条目可以单独或集体地添加和移除。

	~ DoctorsInSurgery = DoctorsInSurgery + Adams
 	~ DoctorsInSurgery += Adams  // 这与上述相同
	~ DoctorsInSurgery -= Eamonn
	~ DoctorsInSurgery += (Eamonn, Denver)
	~ DoctorsInSurgery -= (Adams, Eamonn, Denver)

尝试添加已经在列表中的条目不会有什么变化。尝试移除一个不存在的条目也不会有什么变化。两者都不会产生错误，并且列表永远不能包含重复的条目。

### 基本查询

我们有几种基本方式获取列表中的信息：

	LIST DoctorsInSurgery = (Adams), Bernard, (Cartwright), Denver, Eamonn

	{LIST_COUNT(DoctorsInSurgery)} 	//  "2"
	{LIST_MIN(DoctorsInSurgery)} 		//  "Adams"
	{LIST_MAX(DoctorsInSurgery)} 		//  "Cartwright"
	{LIST_RANDOM(DoctorsInSurgery)} 	//  "Adams" 或 "Cartwright"

#### 测试是否为空

与 ink 中的大多数值一样，列表可以"原样"进行测试，如果为空则返回 true。

	{ DoctorsInSurgery: The surgery is open today. | Everyone has gone home. }

#### 精确相等性测试

测试多值列表比单值列表稍微复杂一些。相等性 (`==`) 现在意味着“集合相等性” - 即，所有条目都是相同的。

所以可以说：

``` 
{ DoctorsInSurgery == (Adams, Bernard):
	Dr Adams 和 Dr Bernard 在一个角落里激烈争论。
}
```

如果 Dr Eamonn 也在场，那么两个人就不会争论，因为被比较的列表不会相等 - DoctorsInSurgery 将包含一个 Eamonn，而列表 (Adams, Bernard) 不包含。

不相等的行为如预期那样工作：

``` 
{ DoctorsInSurgery != (Adams, Bernard):
	至少 Adams 和 Bernard 没有争论。
}
```

#### 测试包含性

如果我们只是想简单地询问 Adams 和 Bernard 是否在场呢？为此我们使用一个新的操作符，`has`，也称为 `?`。

	{ DoctorsInSurgery ? (Adams, Bernard):
		Dr Adams 和 Dr Bernard 在一个角落里小声争论。
	}

`?` 也可以应用于单个值：

	{ DoctorsInSurgery has Eamonn:
		Dr Eamonn 正在擦拭他的眼镜。
	}

我们还可以对其进行否定，使用 `hasnt` 或 `!?`（而不是 `?`）。请注意，这开始变得有些复杂，因为

	DoctorsInSurgery !? (Adams, Bernard)

并不意味着 Adams 和 Bernard 都不在场，而仅仅是他们不*都*在场（并且争论）。

#### 警告：没有列表包含空列表

请注意测试

	SomeList ? ()

将始终返回 false，无论 `SomeList` 本身是否为空。在实践中，这是最有用的默认值，因为您通常会想要进行如下测试：

	SilverWeapons ? best_weapon_to_use 

以在玩家空手时失败。

#### 示例：基本知识追踪

多值列表最简单的使用方式是整洁地追踪“游戏标志”。

``` 
LIST Facts = (Fogg_is_fairly_odd), 	first_name_phileas, (Fogg_is_English)
```

```
{Facts ? Fogg_is_fairly_odd:I smiled politely.|I frowned. Was he a lunatic?}
'{Facts ? first_name_phileas:Phileas|Monsieur}, really!' I cried.
```

特别地，它允许我们在一行中测试多个游戏标志。

```
{ Facts ? (Fogg_is_English, Fogg_is_fairly_odd):
	<> 'I know Englishmen are strange, but this is *incredible*!'
}
```

#### 示例：医生的诊所

我们需要一个更完整的例子，所以给出这个例子。

	LIST DoctorsInSurgery = (Adams), Bernard, Cartwright, (Denver), Eamonn

	-> waiting_room

	=== function whos_in_today()
		今天在诊所的是 {DoctorsInSurgery}。

	=== function doctorEnters(who)
		{ DoctorsInSurgery !? who:
			~ DoctorsInSurgery += who
			医生 {who} 突然到来。
		}

	=== function doctorLeaves(who)
		{ DoctorsInSurgery ? who:
			~ DoctorsInSurgery -= who
			医生 {who} 去吃午餐。
		}

	=== waiting_room
		{whos_in_today()}
		*	[时间过去...]
			{doctorLeaves(Adams)} {doctorEnters(Cartwright)} {doctorEnters(Eamonn)}
			{whos_in_today()}

这将产生：

	今天在诊所的是 Adams, Denver。

	> 时间过去...

	医生 Adams 去吃午餐。医生 Cartwright 突然到来。医生 Eamonn 突然到来。

	今天在诊所的是 Cartwright, Denver, Eamonn。

#### 高级：更美观的列表打印

基本的列表打印在游戏中使用时并不是特别美观。下面的方式更好：

	=== function listWithCommas(list, if_empty)
	    {LIST_COUNT(list):
	    - 2:
	        	{LIST_MIN(list)} 和 {listWithCommas(list - LIST_MIN(list), if_empty)}
	    - 1:
	        	{list}
	    - 0:
				{if_empty}
	    - else:
	      		{LIST_MIN(list)}, {listWithCommas(list - LIST_MIN(list), if_empty)}
	    }

	LIST favouriteDinosaurs = (steogosaurus), brachiosaur, (anklyosaurus), (pleiosaur)

	我最喜欢的恐龙是 {listWithCommas(favouriteDinosaurs, "全部灭绝") }。

可能还需要一个 is/are 函数：

	=== function isAre(list)
		{LIST_COUNT(list) == 1:is|are}

	我最喜欢的恐龙 {isAre(favouriteDinosaurs)} {listWithCommas(favouriteDinosaurs, "全部灭绝") }。

为了更准确：

	我最喜欢的恐龙{LIST_COUNT(favouriteDinosaurs) != 1:s} {isAre(favouriteDinosaurs)} {listWithCommas(favouriteDinosaurs, "全部灭绝") }。

#### 列表不需要包含多个条目

列表不*必须*包含多个值。如果您想将列表用作状态机，上面的示例都可以工作 - 使用 `=`、 `++` 和 `--` 设置值；使用 `==`、 `<`、 `<=`、 `>` 和 `>=` 测试它们。这些都会按预期工作。

### 完整列表

请注意，`LIST_COUNT`、`LIST_MIN` 和 `LIST_MAX` 是指谁在列表中/谁不在列表中，而不是 *可能的* 医生的完整集合。我们可以使用以下方法访问它：

	LIST_ALL(列表中的元素)

或者

	LIST_ALL(包含列表元素的列表)

	{LIST_ALL(DoctorsInSurgery)} // Adams, Bernard, Cartwright, Denver, Eamonn
	{LIST_COUNT(LIST_ALL(DoctorsInSurgery))} // "5"
	{LIST_MIN(LIST_ALL(Eamonn))} 				// "Adams"

请注意，使用 `{...}` 打印列表会产生列表的基本表示；值作为单词，用逗号分隔。

#### 高级： “刷新” 列表的类型

如果你确实需要，你可以创建一个知道其类型的空列表。

    LIST ValueList = first_value, second_value, third_value
    VAR myList = ()

    ~ myList = ValueList()

然后你将能够执行：

    { LIST_ALL(myList) }

#### 高级：部分“完整”列表

您还可以使用 `LIST_RANGE` 函数仅检索“切片”完整列表。有两种有效的公式：

    LIST_RANGE(list_name, min_integer_value, max_integer_value)

和

    LIST_RANGE(list_name, min_value, max_value)
    
此处的最小值和最大值是包含在内的。如果游戏无法找到这些值，它将尽可能接近，但绝不会超出范围。例如：

    {LIST_RANGE(LIST_ALL(primeNumbers), 10, 20)} 

将产生 
    
    11, 13, 17, 19

### 示例：汉诺塔

为了展示这些想法，下面是一个功能性的汉诺塔示例，编写得如此详细，以至于其他人无需再编写它。

```
LIST Discs = one, two, three, four, five, six, seven
VAR post1 = ()
VAR post2 = ()
VAR post3 = ()

~ post1 = LIST_ALL(Discs)

-> gameloop

=== function can_move(from_list, to_list) ===
    {
    -   LIST_COUNT(from_list) == 0:
        // 没有盘子可以移动
        ~ return false
    -   LIST_COUNT(to_list) > 0 && LIST_MIN(from_list) > LIST_MIN(to_list):
        // 移动的盘子比新塔上最小的盘子大
        ~ return false
    -   else:
         // 没有什么阻碍你！
        ~ return true

    }

=== function move_ring( ref from, ref to ) ===
    ~ temp whichRingToMove = LIST_MIN(from)
    ~ from -= whichRingToMove
    ~ to += whichRingToMove

== function getListForTower(towerNum)
    { towerNum:
        - 1:    ~ return post1
        - 2:    ~ return post2
        - 3:    ~ return post3
    }

=== function name(postNum)
    the {postToPlace(postNum)} 寺庙

=== function Name(postNum)
    The {postToPlace(postNum)} 寺庙

=== function postToPlace(postNum)
    { postNum:
        - 1: first
        - 2: second
        - 3: third
    }

=== function describe_pillar(listNum) ==
    ~ temp list = getListForTower(listNum)
    {
    - LIST_COUNT(list) == 0:
        {Name(listNum)} 是空的。
    - LIST_COUNT(list) == 1:
        {list} 盘子位于 {name(listNum)} 上。
    - else:
        在 {name(listNum)} 上，有编号为 {list} 的盘子。
    }


=== gameloop
    从天堂俯瞰，你看到你的追随者完成了最后一座伟大寺庙的建造，准备开始工作。
- (top)
    +  [ 关注寺庙 ]
        你依次关注每一座寺庙。每座寺庙上堆叠着石制的环。 {describe_pillar(1)} {describe_pillar(2)} {describe_pillar(3)}
    <- move_post(1, 2, post1, post2)
    <- move_post(2, 1, post2, post1)
    <- move_post(1, 3, post1, post3)
    <- move_post(3, 1, post3, post1)
    <- move_post(3, 2, post3, post2)
    <- move_post(2, 3, post2, post3)
    -> DONE

= move_post(from_post_num, to_post_num, ref from_post_list, ref to_post_list)
    +   { can_move(from_post_list, to_post_list) }
        [ 将一个盘子从 {name(from_post_num)} 移动到 {name(to_post_num)} ]
        { move_ring(from_post_list, to_post_list) }
        { stopping:
        -   下面的祭司们建造了一个巨大的吊具，经过多年的努力，巨大的石环被抬到空中，并被摆动到下一个寺庙。
            绳子被割断，在眨眼之间它再次落下。
        -   你的下一个命令伴随着盛大的宴会和许多牺牲。当葬礼烟雾散去后，移动巨石环的工作开始了。一代人成长又消逝，环落入它指定的位置。
        -   {cycle:
            - 年复一年，环被缓慢移动。
            - 下面的祭司们为了穿什么颜色的袍子而打了一场战争，但尽管他们倒下并死亡，工作依然完成。
            }
        }
    -> top
```

## 5) 高级列表操作

上述部分涵盖了基本比较。还有一些更强大的特性，不过 - 正如任何熟悉数学集合的人所知道 - 事情开始变得有些复杂。因此，本节附带了一个“高级”警告。

这一部分的许多特性对于大多数游戏来说并不是必需的。

### 比较列表

我们可以使用 `>`、`<`、`>=` 和 `<=` 来不精确地比较列表。请注意！我们使用的定义并不完全是标准的。它们是基于比较正在测试的列表中元素的数值。

#### "明显大于"

`LIST_A > LIST_B` 意味着 "A 中的最小值大于 B 中的最大值"：换句话说，如果将其放在数字线上，A 的全部位于 B 的全部右侧。`<` 以相反的方式执行相同的操作。

#### "绝对不会比小的更小"

`LIST_A >= LIST_B` 的意思是 - 现在深呼吸 - "A 中的最小值至少是 B 中的最小值，A 中的最大值至少是 B 中的最大值"。也就是说，如果在数字线上画出，A 的整个范围要么位于 B 之上，要么与 B 重叠，但 B 不会高于 A。

请注意，`LIST_A > LIST_B` 暗示着 `LIST_A != LIST_B`，而 `LIST_A >= LIST_B` 允许 `LIST_A == LIST_B` 但排除了 `LIST_A < LIST_B`，正如你可能所希望的那样。

#### 健康警告！

`LIST_A >= LIST_B` 并 *不* 等同于 `LIST_A > LIST_B or LIST_A == LIST_B`。

道德是，在你脑海中没有清晰的想法时，不要使用这些。

### 反转列表

列表可以被“反转”，这相当于浏览住宿的进出姓名牌并将每个开关翻转到之前的相反状态。

    LIST GuardsOnDuty = (Smith), (Jones), Carter, Braithwaite

    === function changingOfTheGuard
        ~ GuardsOnDuty = LIST_INVERT(GuardsOnDuty)

请注意，`LIST_INVERT` 在空列表上将返回一个 null 值，如果游戏没有足够的上下文来知道如何反转。如果您需要处理这种情况，手动处理是最安全的：

    === function changingOfTheGuard
        {!GuardsOnDuty: // "现在 GuardsOnDuty 为空吗？"
            ~ GuardsOnDuty = LIST_ALL(Smith)
        - else:
            ~ GuardsOnDuty = LIST_INVERT(GuardsOnDuty)
        }

#### 脚注

反转的语法最初是 `~ list`，但我们进行了更改，因为否则这一行

	~ list = ~ list

不仅是功能性的，而且实际上还导致列表自我反转，这似乎过于扭曲。

### 交集列表

`has` 或 `?` 操作符，正式一点说，是“你是我的子集吗”操作符，⊇，这包括集合相等的情况，但不包括较大集合并不完全包含较小集合的情况。

为了测试列表之间的“某种重叠”，我们使用重叠操作符 `^` 来获取 *交集*。

```
LIST CoreValues = strength, courage, compassion, greed, nepotism, self_belief, delusions_of_godhood
VAR desiredValues = (strength, courage, compassion, self_belief )
VAR actualValues =  ( greed, nepotism, self_belief, delusions_of_godhood )

{desiredValues ^ actualValues} // 打印 "self_belief"
```

结果是一个新列表，因此你可以对其进行测试：

```
{desiredValues ^ actualValues: 新总统至少有一个可取的品质。}

{LIST_COUNT(desiredValues ^ actualValues) == 1: 更正，新总统只有一个可取的品质。 {desiredValues ^ actualValues == self_belief: 那是可怕的那个。}}
```

## 6) 多重列表


到目前为止，我们所有的示例都包括一个大的简化，即列表变量中的所有值必须来自同一个列表系列。但是它们并不需要。

这使我们能够使用列表——到目前为止，它们扮演了状态机和标志跟踪器的角色——作为一般属性，这对于世界建模非常有用。

这是我们的起始时刻。结果是强大的，但也更像是“真实代码”，而不是之前的任何东西。

### 追踪对象的列表

例如，我们可能定义：

	LIST Characters = Alfred, Batman, Robin
	LIST Props = champagne_glass, newspaper

	VAR BallroomContents = (Alfred, Batman, newspaper)
	VAR HallwayContents = (Robin, champagne_glass)

然后，我们可以通过测试其状态来描述任何房间的内容：

	=== function describe_room(roomState)
		{ roomState ? Alfred: Alfred 在这里，安静地站在角落里。 } { roomState ? Batman: 蝙蝠侠的存在主宰了一切。 } { roomState ? Robin: 罗宾几乎被遗忘。 }
		<> { roomState ? champagne_glass: 一个香槟杯被丢弃在地板上。 } { roomState ? newspaper: 在一张桌子上，头条大声地喊着 WHO IS THE BATMAN? AND *WHO* IS HIS BARELY-REMEMBERED ASSISTANT? }

那么：

	{ describe_room(BallroomContents) }

产生：

	Alfred 在这里，安静地站在角落里。蝙蝠侠的存在主宰了一切。

	在一张桌子上，头条大声地喊着 WHO IS THE BATMAN? AND *WHO* IS HIS BARELY-REMEMBERED ASSISTANT?

而：

	{ describe_room(HallwayContents) }

给出：

	罗宾几乎被遗忘。

	一个香槟杯被丢弃在地板上。

我们还可以根据事物的组合提供选项：

	*	{ currentRoomState ? (Batman, Alfred) } [与阿尔弗雷德和蝙蝠侠交谈]
		'说，你们两个相互认识吗？'

### 用于跟踪多个状态的列表

我们可以对具有多个状态的设备进行建模。再次回到电水壶...

```
LIST OnOff = on, off
LIST HotCold = cold, warm, hot

VAR kettleState = (off, cold) // 我们需要括号，因为这现在是一个正确的多值列表
```

=== function turnOnKettle() ===
``` 
{ kettleState ? hot:
	You turn on the kettle, but it immediately flips off again.
- else:
	The water in the kettle begins to heat up.
	~ kettleState -= off
	~ kettleState += on
	// 注意我们避免使用 "="，因为这样会移除所有现有状态
}
```

=== function can_make_tea() ===
```
	~ return kettleState ? (hot, off)
```

这些混合状态可能会使状态变化变得有些棘手，正如上面所示的开/关状态，因此以下辅助函数可能会很有用。

=== function changeStateTo(ref stateVariable, stateToReach)
``` 
	// 移除所有此类型的状态
	~ stateVariable -= LIST_ALL(stateToReach)
	// 重新添加我们想要的状态
	~ stateVariable += stateToReach
```

这使得像这样的代码成为可能：

```
	~ changeState(kettleState, on)
	~ changeState(kettleState, warm)
```

#### 这如何影响查询？

上述查询大多数可以很好地推广到多值列表

    LIST Letters = a,b,c
    LIST Numbers = one, two, three

    VAR mixedList = (a, three, c)

	{LIST_ALL(mixedList)}   // a, one, b, two, c, three
    {LIST_COUNT(mixedList)} // 3
    {LIST_MIN(mixedList)}   // a
    {LIST_MAX(mixedList)}   // three 或 c，但不可预测

    {mixedList ? (a,b) }        // false
    {mixedList ^ LIST_ALL(a)}   // a, c

    { mixedList >= (one, a) }   // true
    { mixedList < (three) }     // false

	{ LIST_INVERT(mixedList) }            // one, b, two

## 7) 长示例：犯罪现场

最后，这里有一个长示例，展示了本部分很多思想的实际应用。您可能希望在阅读之前先试着玩一下，以更好地理解各种动态部分。

	-> murder_scene

	// 辅助函数：从列表中弹出元素
	=== function pop(ref list)
	   ~ temp x = LIST_MIN(list) 
	   ~ list -= x 
	   ~ return x
	
	//
	//  系统：项可以有各种状态
	//  一些是一般的，有一些是特定于特定项的
	//
	

	LIST OffOn = off, on
	LIST SeenUnseen = unseen, seen
	
	LIST GlassState = (none), steamed, steam_gone
	LIST BedState = (made_up), covers_shifted, covers_off, bloodstain_visible
	
	//
	// 系统：库存
	//
	
	LIST Inventory = (none), cane, knife
	
	=== function get(x)
	    ~ Inventory += x
	
	//
	// 系统：物品定位
	// 项可以放在地方上或地方里面
	//
	
	LIST Supporters = on_desk, on_floor, on_bed, under_bed, held, with_joe
	
	=== function move_to_supporter(ref item_state, new_supporter) ===
	    ~ item_state -= LIST_ALL(Supporters)
	    ~ item_state += new_supporter
	
	
	// 系统：增量知识。
	// 每个列表都是一个事实链。每个事实都取代前一个事实 
	//
	
	VAR knowledgeState = ()
	
	=== function reached (x) 
	   ~ return knowledgeState ? x 
	
	=== function between(x, y) 
	   ~ return knowledgeState? x && not (knowledgeState ^ y)
	
	=== function reach(statesToSet) 
	   ~ temp x = pop(statesToSet)
	   {
	   - not x: 
	      ~ return false 
	
	   - not reached(x):
	      ~ temp chain = LIST_ALL(x)
	      ~ temp statesGained = LIST_RANGE(chain, LIST_MIN(chain), x)
	      ~ knowledgeState += statesGained
	      ~ reach (statesToSet) 	// 设置剩余的状态
	      ~ return true  	       // 并且我们设置了这个状态，所以为真
	 
	    - else:
	      ~ return false || reach(statesToSet) 
	    }	
	
	//
	// 设置游戏
	//
	
	VAR bedroomLightState = (off, on_desk)
	
	VAR knifeState = (under_bed)
	
	
	//
	// 知识链
	//
	
	
	LIST BedKnowledge = neatly_made, crumpled_duvet, hastily_remade, body_on_bed, murdered_in_bed, murdered_while_asleep
	
	LIST KnifeKnowledge = prints_on_knife, joe_seen_prints_on_knife, joe_wants_better_prints, joe_got_better_prints
	
	LIST WindowKnowledge = steam_on_glass, fingerprints_on_glass, fingerprints_on_glass_match_knife
	
	
	//
	// 内容
	//
	
	=== murder_scene ===
	    卧室。这就是事情发生的地方。现在去寻找线索。
	- (顶)
	    { bedroomLightState ? seen:     <- seen_light  }
	    <- compare_prints(-> top)

    *   (dobed) [床...]
        床很低，但也不至于低到有什么东西会在下面滚动。它依然整齐地铺好。
        ~ reach (neatly_made)
        - - (bedhub)
        * *     [掀起床单]
                我掀开了床单。下面的被子皱巴巴的。
                ~ reach (crumpled_duvet)
                ~ BedState = covers_shifted
        * *     (uncover) {reached(crumpled_duvet)}
                [去掉被罩]
                小心不要扰动下面的东西，我将被罩完全移开。下面的被子皱皱的。
                这不是女佣干的，她是一个尽心尽力的人。显然这是匆忙扔上的。
                ~ reach (hastily_remade)
                ~ BedState = covers_off
        * *     (duvet) {BedState == covers_off} [拉开被子]
                我拉开了被子。下面是一张带血的床单。
                ~ BedState = bloodstain_visible
                ~ reach (body_on_bed)
                要么尸体在被拖到地板之前被移动到这里——要么这里就是谋杀发生的地方。
        * *     {BedState !? made_up} [重新整理床铺]
                我小心翼翼地将床单拉回原位，试图让它看起来没有被打扰过。
                ~ BedState = made_up
        * *     [测试床]
                我用张开的手掌推了推床。它 creaked 一声，但声音不算大到讨厌。
        * *     (darkunder) [看看床下]
                我躺下，试图探头看看床下，但什么也看不清。

        * *     {TURNS_SINCE(-> dobed) > 1} [还有什么？]
                我从床边后退了一步，四处张望。
                -> top
        - -     -> bedhub

    *   {darkunder && bedroomLightState ? on_floor && bedroomLightState ? on}
        [ 看看床下 ]
        我看着床下。有什么东西在向我闪光。
        - - (reaching)
        * *     [ 去抓它 ]
                我用一只手伸到床下，但无论它是什么，已经被踢得远了，我无法触及它。
                -> reaching
        * *     {Inventory ? cane} [用手杖敲打它]
                -> knock_with_cane

        * *     {reaching > 1 } [ 站起来 ]
                我再次站了起来，拍了拍我的外套。
                -> top

    *   (knock_with_cane) {reaching && TURNS_SINCE(-> reaching) >= 4 &&  Inventory ? cane } [用手杖到床下伸手 ]
        我将手杖放在地毯上，给那个闪光的东西轻轻敲了一下。它从床脚滑了出来。
        ~ move_to_supporter( knifeState, on_floor )
        * *     (standup) [站起来]
                满意地，我站了起来，看到了我敲出来一个沾血的刀子。
                -> top

        * *     [再看看床下]
                我移开手杖，再次看了看床下，但没有更多东西。
                -> standup

    *   {knifeState ? on_floor} [捡起刀]
        小心不要碰到刀柄，我从地毯上抬起刀刃。
        ~ get(knife)

    *   {Inventory ? knife} [看看刀]
        血已经干了。干得足以在刀柄上留下部分指纹！
        ~ reach (prints_on_knife)

    *   [桌子...]
        我把注意力转向桌子。一盏灯在一个角落，另一边是整齐的空信件盒。没有其他东西。
        一根木制手杖靠在桌子上。
        ~ bedroomLightState += seen

        - - (deskstate)
        * *     (pickup_cane) {Inventory !? cane}  [捡起手杖 ]
                ~ get(cane)
              我捡起了木制手杖。它很重，没有任何标记。

        * *    { bedroomLightState !? on } [打开灯]
                -> operate_lamp ->

        * *     [看看信件盒 ]
                我查看了信件盒，但没有什么可看。要么是受害者的文件被拿走了，要么他的生意已经干涸。或者信件盒只是个摆设。

        + +     (open)  {open < 3} [打开一个抽屉]
                我随机尝试打开 {一个抽屉|另一个抽屉|第三个抽屉}。{锁住|也锁住|毫不奇怪的是，锁住了。}

        * *     {deskstate >= 2} [还有什么？]
                我再次从桌子上走开。
                -> top

        - -     -> deskstate

    *     {(Inventory ? cane) && TURNS_SINCE(-> deskstate) <= 2} [挥舞手杖]
        我还在握着手杖：我实验性地挥了一下。它确实很重，但并不是用作重锤的那种重。
        但它可能在自卫时很有用。为什么受害者没有去抓它？倒下了？

    *   [窗户...]
        我走到窗户前，向外张望。小溪沿房子旁流淌，视野十分阴暗。

        - - (window_opts)
        <- compare_prints(-> window_opts)
        * *     (downy) [看看小河]
                { GlassState ? steamed:
                    透过蒸汽的玻璃，我看不见小河。 -> see_prints_on_glass -> window_opts
                }
                我看着小溪流过一会儿。房子可能潮湿，但除此之外，它告诉我什么都没有。
        * *     (greasy) [看看玻璃]
                { GlassState ? steamed: -> downy }
                窗户上的玻璃很油腻。里外都没人清理过。
        * *     { GlassState ? steamed && not see_prints_on_glass && downy && greasy }
                [ 看看蒸汽 ]
                外面是寒冷的日子。自然我的呼吸应该会蒸汽化。 -> see_prints_on_glass ->
        + +     {GlassState ? steam_gone} [ 对着玻璃呼吸 ]
                我再次轻轻对着玻璃呼吸。{ reached (fingerprints_on_glass): 指纹再次显现。 }
                ~ GlassState = steamed

        + +     [还有其他吗？]
                { window_opts < 2 || reached (fingerprints_on_glass) || GlassState ? steamed:
                    我从阴沉的玻璃上移开了目光。
                    {GlassState ? steamed:
                        ~ GlassState = steam_gone
                        <> 我呼出的蒸汽逐渐消散。
                    }
                    -> top
                }
                我向后靠了一下。我的呼吸稍微在窗户上留下了些蒸汽。
               ~ GlassState = steamed

        - -     -> window_opts

    *   {top >= 5} [离开房间]
        我已经看够了。我{bedroomLightState ? on:关掉了灯，然后}转身离开了房间。
        -> joe_in_hall

    -   -> top
	
	
	= operate_lamp
	    我按下了开关。
	    { bedroomLightState ? on:
	        <> 灯泡变暗了。
	        ~ bedroomLightState += off
	        ~ bedroomLightState -= on
	    - else:
	        { bedroomLightState ? on_floor: <> 一些光线洒落在床下。} { bedroomLightState ? on_desk : <> 灯光在光滑的桌面上闪烁。 }
	        ~ bedroomLightState -= off
	        ~ bedroomLightState += on
	    }
	    ->->
	
	
	= compare_prints (-> backto)
	    *   { between ((fingerprints_on_glass, prints_on_knife),     fingerprints_on_glass_match_knife) } 
	[比较刀子和窗户上的指纹 ]
	        我将沾满血的刀靠近窗户，再次呼吸以显现指纹，并尽我所能进行比较。
	        几乎不是科学，但它们看起来非常相似——确实非常相似。
	        ~ reach (fingerprints_on_glass_match_knife)
	        -> backto
	
	= see_prints_on_glass
	    ~ reach (fingerprints_on_glass)
	    {但我能看到几个指纹，仿佛有人按压着手掌。|指纹十分清晰且轮廓分明。} 它们在我观看时渐渐消失。
	    ~ GlassState = steam_gone
	    ->->

	= seen_light
	    *   {bedroomLightState !? on} [ 打开灯 ]
	        -> operate_lamp ->

	    *   { bedroomLightState !? on_bed  && BedState ? bloodstain_visible }
	        [ 把光移到床上 ]
	        ~ move_to_supporter(bedroomLightState, on_bed)
	
	        我把光移动到血渍上，仔细观察它。血液深深渗入了棉床单的纤维中。
	        毫无疑问。这是击打的地方。
	        ~ reach (murdered_in_bed)
	
	    *   { bedroomLightState !? on_desk } {TURNS_SINCE(-> floorit) >= 2 }
	        [ 把光移回桌子上 ]
	        ~ move_to_supporter(bedroomLightState, on_desk)
	        我把光移回到桌子上，放回原来的地方。
	    *   (floorit) { bedroomLightState !? on_floor && darkunder }
	        [将光移动到地板上 ]
	        ~ move_to_supporter(bedroomLightState, on_floor)
	        我拿起灯，放在地板上。
	    -   -> top
	
	=== joe_in_hall
	    我的警察联系人，乔，正等在走廊里。“那么？”他问。“你找到什么有趣的事情了吗？”
	- (found)
	    *   {found == 1} '没有。'
	        他耸了耸肩。“可惜。”
	        -> done
	    *   { Inventory ? knife } '我找到了谋杀武器。'
	        “做得好！”乔带着微笑回答。“我们以为谋杀犯已经处理掉它了。我现在给你装袋。”
	        ~ move_to_supporter(knifeState, with_joe)
	
	    *   {reached(prints_on_knife)} { knifeState ? with_joe }
	        “刀刃上有指纹[.]”，我告诉他。
	        他仔细看了看。
	        “嗯。不是很完整。从这些很难找到匹配。”
	        ~ reach (joe_seen_prints_on_knife)
	    *   { reached((fingerprints_on_glass_match_knife, joe_seen_prints_on_knife)) }
	        “它们也和窗口上的一组指纹匹配。”
	        “任何人都可以碰到窗户，”乔若有所思地回答。“但如果它们更完整，它们应该能帮我们找到一个不错的匹配！”
	        ~ reach (joe_wants_better_prints)
	    *   { between(body_on_bed, murdered_in_bed)}
	        “尸体在某个时候被移到了床上[.]”，我告诉他。“然后被移回地板上。”
	        “为什么？”
	        * *     “我不知道。”
	                乔点头。“好吧。”
	        * *     “也许是为了从地板上拿东西？”
	                “你不会为此搬动整具尸体。”
	        * *     “也许他是在床上被杀的。”
	                “到目前为止，都只是推测，”乔评论道。
	    *   { reached(murdered_in_bed) }
	        “受害者是在床上被谋杀的，然后尸体被移到了地板上。”
	        “为什么？”
	        * *     “我不知道。”
	                乔点头。“那么好吧。”
	        * *     “也许谋杀犯想误导我们。”
	                “怎么说？”
	            * * *   “他们想让我们认为受害者是清醒的[.]”，我若有所思地回答。“他们是在和攻击者交谈，而不是在睡觉时被刺。”
	            * * *   “他们想让我们认为有某种挣扎[.]”，我回答。“受害者并不是简单地在睡梦中被刺。”
	            - - -   “但如果他们是在床上被杀，那最可能发生的就是这样。在睡梦中被刺。”
	                    ~ reach (murdered_while_asleep)
	        * *     “也许谋杀犯希望清理现场。”
	                “但他们被打扰了？有可能。” 
	
	    *   { found > 1} '就是这样。'
	        “好吧。这是一个开始。”乔回答。
	        -> done
	    -   -> found
	-   (done)
	    {
	    - between(joe_wants_better_prints, joe_got_better_prints):
	        ~ reach (joe_got_better_prints)
	        <> '我现在去拿窗户上的指纹。'
	    - reached(joe_seen_prints_on_knife):
	        <> '我会尽我所能处理这些指纹。'
	    - else:
	        <> '没有多少线索。'
	    }
	    -> END

## 8) 摘要

为了总结一个困难的部分，**ink** 的列表构造提供：

### 标志
* 每个列表条目是一个事件
* 使用 `+=` 来标记事件已经发生
* 使用 `?` 和 `!?` 进行测试

示例：

	LIST GameEvents = foundSword, openedCasket, metGorgon
	{ GameEvents ? openedCasket }
	{ GameEvents ? (foundSword, metGorgon) }
	~ GameEvents += metGorgon

### 状态机
* 每个列表条目都是一个状态
* 使用 `=` 设置状态；使用 `++` 和 `--` 向前或向后移动
* 使用 `==`、`>` 等进行测试

示例：

```
LIST PancakeState = ingredients_gathered, batter_mix, pan_hot, pancakes_tossed, ready_to_eat
{ PancakeState == batter_mix }
{ PancakeState < ready_to_eat }
~ PancakeState++
```

### 属性
* 每个列表是一个不同的属性，具有该属性可以取的状态值（开启或关闭、亮或灭等）。
* 通过移除旧状态，然后添加新状态来改变状态。
* 使用 `?` 和 `!?` 进行测试。

示例：

```
LIST OnOffState = on, off
LIST ChargeState = uncharged, charging, charged

VAR PhoneState = (off, uncharged)

* {PhoneState !? uncharged } [插入手机充电]
    ~ PhoneState -= LIST_ALL(ChargeState)
    ~ PhoneState += charging
    你将手机插入充电器。
* { PhoneState ? (on, charged) } [给我母亲打电话]
```

# 第6部分：标识符中的国际字符支持

默认情况下，ink 在故事内容中对非 ASCII 字符的使用没有限制。然而，当前对可以用于常量、变量、缝合、转移和其他命名流程元素（即 *标识符*）的字符存在限制。

对于使用非 ASCII 语言的作者来说，编写故事有时会很不方便，因为他们必须不断切换到用 ASCII 命名标识符，然后再切换回用于故事的语言。此外，使用作者自己语言命名标识符可能会提高原始故事格式的整体可读性。

为了帮助上述情况，ink *自动* 支持可以用作标识符的预定义非 ASCII 字符范围列表。一般来说，这些范围已被选择以包含官方 Unicode 字符范围的字母数字子集，这足以用于命名标识符。下面的部分提供有关 ink 自动支持的非 ASCII 字符的更详细信息。

### 支持的标识符字符

目前，ink 对附加字符范围的支持仅限于一组预定义的字符范围。

以下是当前支持的标识符范围列表。

 - **阿拉伯语**

   启用阿拉伯语家族语言的字符，并且是官方 *阿拉伯语* unicode 范围 `\u0600`-`\u06FF` 的子集。


 - **亚美尼亚语**

   启用亚美尼亚语言的字符，并且是官方 *亚美尼亚语* unicode 范围 `\u0530`-`\u058F` 的子集。


 - **西里尔字母**

   启用使用西里尔字母的语言字符，并且是官方 *西里尔字母* unicode 范围 `\u0400`-`\u04FF` 的子集。


 - **希腊语**

   启用使用希腊字母的语言字符，并且是官方 *希腊语和科普特语* unicode 范围 `\u0370`-`\u03FF` 的子集。


 - **希伯来语**

   启用使用希伯来字母的希伯来语字符，并且是官方 *希伯来语* unicode 范围 `\u0590`-`\u05FF` 的子集。


 - **扩展拉丁字母 A**

   启用拉丁字母的扩展字符范围子集 - 完全由官方 *拉丁扩展-A* unicode 范围 `\u0100`-`\u017F` 表示。


 - **扩展拉丁字母 B**

   启用拉丁字母的扩展字符范围子集 - 完全由官方 *拉丁扩展-B* unicode 范围 `\u0180`-`\u024F` 表示。

- **拉丁 1 补充字符**

   启用拉丁字母的扩展字符范围子集 - 完全由官方 *拉丁 1 补充* unicode 范围 `\u0080` - `\u00FF` 表示。


**注意！** ink 文件应以 UTF-8 格式保存，这确保上述字符范围受到支持。

如果您希望在标识符中使用的特定字符范围不受支持，请随时在主要 ink 存储库中打开 [问题](/inkle/ink/issues/new) 或 [拉取请求](/inkle/ink/pulls)。